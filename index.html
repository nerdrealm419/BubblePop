<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pop! Pop! Bubble Stop!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #3b8bbe;
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        h1 {
            margin-bottom: 10px;
            font-family: 'Fredoka One', cursive;
            font-size: 2.5em;
            color: white;
            text-shadow: 2px 2px 4px #4a2d6b;
            z-index: 1;
        }
        #game-container {
            position: relative;
            width: 95%;
            max-width: 500px; 
            aspect-ratio: 5 / 6;
            background-color: #d6e8fa;
            border: 5px solid #a3c1e3;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            border-radius: 10px;
            z-index: 1;
        }
        canvas {
            display: block;
            background-color: transparent;
            width: 100%;
            height: 100%;
        }
        
        #ui-container {
            width: 95%;
            max-width: 500px;
            margin-top: 15px;
            padding: 10px;
            box-sizing: border-box;
            background-color: #d6e8fa;
            border: 5px solid #a3c1e3;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px 15px;
            color: #4a2d6b;
            font-size: 18px;
            font-weight: bold;
            z-index: 1;
        }
        .ui-button {
            padding: 5px 10px; font-size: 14px; font-weight: bold; cursor: pointer;
            border: 2px solid #4a2d6b; background-color: white; color: #4a2d6b; border-radius: 5px;
        }
        .next-bubble-area {
            display: flex; align-items: center; gap: 8px;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.08); }
        }
        .high-score-text {
            color: #ffb700;
            text-shadow: 0 0 4px #c77d00;
            animation: pulse 1.5s infinite alternate ease-in-out;
        }

        .overlay-screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.5em;
        }
        .overlay-screen h2 {
            font-family: 'Fredoka One', cursive; margin-top: 0; margin-bottom: 20px;
            font-size: 1.8em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .overlay-screen button {
            margin-top: 20px; padding: 15px 30px;
            font-size: 1em; font-weight: bold; font-family: 'Fredoka One', cursive;
            cursor: pointer; border: 2px solid white; background-color: #8c6ba9;
            color: white; border-radius: 10px; transition: transform 0.1s ease;
        }
        .overlay-screen button:hover { transform: scale(1.05); }

        #rules-overlay ul { list-style: none; padding: 0; margin: 0; font-size: 0.7em; max-width: 80%;}
        #rules-overlay li { margin-bottom: 15px; }
        #game-over { display: none; }
        #start-overlay { display: none; }
        .score-display { font-size: 0.8em; margin: 0; }
        
        @keyframes glow {
            0% { text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000, 0 0 15px #ff4d4d, 0 0 20px #ff4d4d; }
            50% { text-shadow: 0 0 10px #ff4d4d, 0 0 20px #ff8080, 0 0 30px #ffb3b3, 0 0 40px #ffb3b3; }
            100% { text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000, 0 0 15px #ff4d4d, 0 0 20px #ff4d4d; }
        }

        #congrats-text {
            color: #ff1a1a;
            font-family: 'Fredoka One', cursive;
            font-size: clamp(1.8em, 6vw, 2.4em);
            margin-bottom: 15px;
            line-height: 1.2;
            animation: glow 1.5s infinite ease-in-out;
        }

        #new-high-score-value {
            font-family: 'Fredoka One', cursive;
            font-size: clamp(2.5em, 8vw, 3.5em);
            color: #ffcc00;
            text-shadow: 0 0 5px #c77d00, 0 0 10px #c77d00;
            margin: 10px 0;
            -webkit-text-stroke: 1px #8a5a00;
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>

    <h1>Pop! Pop! Bubble Stop!</h1>
    <div id="game-container">
        <canvas id="gameCanvas" width="500" height="600"></canvas>
        <div id="rules-overlay" class="overlay-screen">
            <h2>How to Play</h2>
            <ul>
                <li>Match 3+ bubbles to score.</li>
                <li>A powerful Bomb Bubble may appear to clear a large area!</li>
                <li>An extra life bubble may appear. Pop it to remove a miss!</li>
                <li>5 misses and you lose!</li>
                <li>Clear all the bubbles to win a huge bonus!</li>
            </ul>
            <button id="continue-button">Continue</button>
        </div>
        <div id="start-overlay" class="overlay-screen"> <button id="play-button">Play!</button> </div>
        <div id="game-over" class="overlay-screen">
            <div id="new-high-score-message" style="display: none;">
                <h2 id="congrats-text">Congratulations!<br>New High Score!</h2>
                <p id="new-high-score-value">0</p>
            </div>
            <div id="default-end-message">
                <h2 id="end-message">Game Over</h2>
                <p class="score-display">Final Score: <span id="finalScore">0</span></p>
                <p class="score-display">High Score: <span id="highScore">0</span></p>
            </div>
            <button id="play-again-button">Play Again</button>
        </div>
    </div>
    
    <div id="ui-container">
        <button id="sound-toggle-button" class="ui-button">Sound OFF</button>
        <div>Score: <span id="score">0</span></div>
        <div>High: <span id="current-high-score" class="high-score-text">0</span></div>
        <div>Misses: <span id="miss-counter">0</span>/5</div>
        <button id="restart-button" class="ui-button">Restart</button>
        <div class="next-bubble-area">
            <span>Next:</span>
            <canvas id="nextBubbleCanvas" width="40" height="40"></canvas>
        </div>
    </div>

<script>
// --- Game Setup & Constants ---
const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
const nextBubbleCanvas = document.getElementById('nextBubbleCanvas'), nextCtx = nextBubbleCanvas.getContext('2d');
const backgroundCanvas = document.getElementById('backgroundCanvas'), bgCtx = backgroundCanvas.getContext('2d');
backgroundCanvas.width = window.innerWidth;
backgroundCanvas.height = window.innerHeight;

const gameOverEl = document.getElementById('game-over');
const scoreEl = document.getElementById('score');
const missCounterEl = document.getElementById('miss-counter');
const finalScoreEl = document.getElementById('finalScore'), rulesOverlay = document.getElementById('rules-overlay');
const startOverlay = document.getElementById('start-overlay'), endMessageEl = document.getElementById('end-message');
const highScoreEl = document.getElementById('highScore');
const currentHighScoreEl = document.getElementById('current-high-score');
const HIGH_SCORE_KEY = 'popPopBubbleStopHighScore';

const newHighScoreMessageEl = document.getElementById('new-high-score-message');
const newHighScoreValueEl = document.getElementById('new-high-score-value');
const defaultEndMessageEl = document.getElementById('default-end-message');


const COLS = 12, ROWS = 14;
const SHOTS_UNTIL_LOSS = 5;
const TIME_UNTIL_ROW_DROP = 30 * 60;
const BOMB_INTERVAL = 35 * 60; 
const FLOATING_POINTS_DURATION = 75, POP_PARTICLE_COUNT = 8, POP_PARTICLE_DURATION = 40;
const PADDING = 5;
const BUBBLE_RADIUS = (canvas.width - PADDING * 2) / (COLS * 2);
const HEX_WIDTH = BUBBLE_RADIUS * 2, HEX_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS;
const offsetX = PADDING + BUBBLE_RADIUS, offsetY = PADDING + BUBBLE_RADIUS;
const GAME_OVER_LINE_Y = canvas.height - BUBBLE_RADIUS * 4;
const COLORS = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF', '#FFFF33'];
const SPECIALS = { 'RAINBOW': 'rainbow', 'LIFE': 'life', 'BOMB': 'bomb' };
const AIM_TICK_ANGLE_STEP = Math.PI / 24;

// --- Game State ---
let grid, playerBubble, nextBubble, score, shotsFired, rowDropTimer, bombTimer;
let isFiring = false, aim = { x: canvas.width / 2, y: 0 };
let popAnimations = [], floatingPoints = [], fireworks = [], rain = [], bombSparks = [];
let gameState = 'rules';
let backgroundBubbles = [];
// --- Sound State ---
let audioCtx, isMuted = true, sizzleInterval = null, chimeInterval = null;
let lastAimStep = 0;

// --- Sound Synthesis Functions ---
function playSound(type, ...args) { if (isMuted || !audioCtx) return; const now = audioCtx.currentTime; if (type === 'launch') { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.connect(gain); gain.connect(audioCtx.destination); osc.type = 'sine'; gain.gain.setValueAtTime(0.3, now); osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(100, now + 0.2); gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2); osc.start(now); osc.stop(now + 0.2); } else if (type === 'pop') {
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.type = 'triangle';
        gain.gain.setValueAtTime(0.3, now);
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'chimeLoopStart') {
        stopChimeLoop(); if (isMuted) return; 
        const notes = [880.00, 987.77, 1174.66, 1396.91, 1567.98]; 
        let noteIndex = 0; 
        chimeInterval = setInterval(() => { 
            if (isMuted || !audioCtx) { stopChimeLoop(); return; } 
            const chimeNow = audioCtx.currentTime; 
            const osc = audioCtx.createOscillator(); 
            const gain = audioCtx.createGain(); 
            osc.connect(gain); gain.connect(audioCtx.destination); 
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.08, chimeNow);
            osc.frequency.setValueAtTime(notes[noteIndex], chimeNow); 
            gain.gain.exponentialRampToValueAtTime(0.0001, chimeNow + 1.2);
            osc.start(chimeNow); 
            osc.stop(chimeNow + 1.2);
            noteIndex = (noteIndex + 1) % notes.length; 
        }, 800);
    } else if (type === 'explosion') {
        const boomOsc = audioCtx.createOscillator();
        const boomGain = audioCtx.createGain();
        boomOsc.connect(boomGain);
        boomGain.connect(audioCtx.destination);
        boomOsc.type = 'triangle';
        boomOsc.frequency.setValueAtTime(100, now);
        boomOsc.frequency.exponentialRampToValueAtTime(20, now + 0.5);
        boomGain.gain.setValueAtTime(0.8, now);
        boomGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        boomOsc.start(now);
        boomOsc.stop(now + 0.5);
        const bufferSize = audioCtx.sampleRate * 1;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const crackleGain = audioCtx.createGain();
        const bandpass = audioCtx.createBiquadFilter();
        bandpass.type = 'bandpass';
        bandpass.frequency.value = 1200;
        bandpass.Q.value = 0.8;
        noise.connect(bandpass);
        bandpass.connect(crackleGain);
        crackleGain.connect(audioCtx.destination);
        crackleGain.gain.setValueAtTime(0.6, now);
        crackleGain.gain.exponentialRampToValueAtTime(0.0001, now + 1);
        noise.start(now);
        noise.stop(now + 1);
    } else if (type === 'sizzleStart') {
        stopSizzle();
        sizzleInterval = setInterval(() => {
            if (isMuted || !audioCtx) { stopSizzle(); return; }
            const sizzleNow = audioCtx.currentTime;
            const bufferSize = audioCtx.sampleRate * 0.05;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1500;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.1, sizzleNow);
            gain.gain.exponentialRampToValueAtTime(0.0001, sizzleNow + 0.05);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start(sizzleNow);
            noise.stop(sizzleNow + 0.05);
        }, 70);
    } else if (type === 'tick') {
        const bufferSize = audioCtx.sampleRate * 0.01;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
        noise.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start(now);
        noise.stop(now + 0.05);
    } else if (type === 'lifeGet') {
        // MODIFICATION: Added a new sound for getting a life
        const notes = [880, 1046.5, 1318.5]; // A5, C6, E6 arpeggio
        const gain = audioCtx.createGain();
        gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(0.25, now);
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            osc.connect(gain);
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(freq, now + i * 0.07);
            osc.start(now + i * 0.07);
            osc.stop(now + i * 0.07 + 0.1);
        });
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
    }
}
function stopSizzle() { if (sizzleInterval) { clearInterval(sizzleInterval); sizzleInterval = null; } }
function stopChimeLoop() { if (chimeInterval) { clearInterval(chimeInterval); chimeInterval = null; } }

function getHighScore() { const scoreStr = localStorage.getItem(HIGH_SCORE_KEY); return scoreStr ? parseInt(scoreStr, 10) : 0; }
function saveHighScore(newScore) { localStorage.setItem(HIGH_SCORE_KEY, newScore.toString()); }
function hexToRgba(hex, alpha) { if(!hex) return `rgba(0,0,0,${alpha})`; const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return r?`rgba(${parseInt(r[1],16)},${parseInt(r[2],16)},${parseInt(r[3],16)},${alpha})`:`rgba(0,0,0,${alpha})`;}
function createBubble(row, col, color=null, type='normal') { if(color===null)color=COLORS[Math.floor(Math.random()*COLORS.length)]; const x = offsetX + col*HEX_WIDTH + (row%2)*BUBBLE_RADIUS; const y = offsetY + row*HEX_HEIGHT; return {row,col,x,y,color,type,vx:0,vy:0};}
function generateNextBubble() { let color = COLORS[Math.floor(Math.random()*COLORS.length)], type='normal'; if(Math.random() < 0.10){ type=SPECIALS.RAINBOW; color=null; } return {x:canvas.width/2,y:canvas.height-BUBBLE_RADIUS,color,type,vx:0,vy:0};}

function init() { grid = Array(ROWS).fill(null).map(()=>Array(COLS).fill(null)); score=0; shotsFired=0; isFiring=false; rowDropTimer=0; bombTimer=0; popAnimations=[]; floatingPoints=[]; fireworks=[]; rain=[]; bombSparks=[]; gameState = 'pregame'; lastAimStep = 0; for (let r=0;r<4;r++) for (let c=0;c<COLS;c++) if (!((r%2===1)&&c===COLS-1)) grid[r][c]=createBubble(r, c); const corners = [{r: 0, c: 0}, {r: 0, c: COLS - 1}]; const randomCorner = corners[Math.floor(Math.random() * corners.length)]; if(grid[randomCorner.r][randomCorner.c]) { grid[randomCorner.r][randomCorner.c].type = 'life'; grid[randomCorner.r][randomCorner.c].color = '#ffffff'; } playerBubble=generateNextBubble(); if (playerBubble.type === 'rainbow') { playSound('chimeLoopStart'); } else if (playerBubble.type === 'bomb') { playSound('sizzleStart'); } nextBubble=generateNextBubble(); currentHighScoreEl.innerText = getHighScore(); updateUI(); }
function updateUI() { scoreEl.innerText=score; missCounterEl.innerText = shotsFired; nextCtx.clearRect(0,0,nextBubbleCanvas.width,nextBubbleCanvas.height); drawBubble(nextCtx,{...nextBubble,x:nextBubbleCanvas.width/2,y:nextBubbleCanvas.height/2,radius:BUBBLE_RADIUS*0.8});}

function drawBubble(context, bubble) { if (!bubble) return; const radius = bubble.radius || BUBBLE_RADIUS; if (bubble.type === 'life') { context.beginPath(); context.fillStyle = '#ffffff'; context.arc(bubble.x, bubble.y, radius, 0, Math.PI * 2); context.fill(); context.strokeStyle = '#ff0000'; context.lineWidth = 4; context.stroke(); const plusSize = radius * 0.5; context.beginPath(); context.moveTo(bubble.x, bubble.y - plusSize); context.lineTo(bubble.x, bubble.y + plusSize); context.moveTo(bubble.x - plusSize, bubble.y); context.lineTo(bubble.x + plusSize, bubble.y); context.stroke(); context.lineWidth = 1; return; } if (bubble.type === 'bomb') { const grad = context.createRadialGradient(bubble.x, bubble.y, radius * 0.1, bubble.x, bubble.y, radius); grad.addColorStop(0, '#333'); grad.addColorStop(1, '#000'); context.fillStyle = grad; context.beginPath(); context.arc(bubble.x, bubble.y, radius, 0, Math.PI * 2); context.fill(); context.fillStyle = '#a3a3a3'; context.beginPath(); context.arc(bubble.x, bubble.y - radius * 0.7, radius * 0.2, 0, Math.PI * 2); context.fill(); context.strokeStyle = '#d3a375'; context.lineWidth = 3; context.beginPath(); const wickStartX = bubble.x, wickStartY = bubble.y - radius * 0.7; const wickEndX = bubble.x + radius * 0.5, wickEndY = bubble.y - radius * 1.4; const cpX = bubble.x + radius * 0.4, cpY = bubble.y - radius * 1.6; context.moveTo(wickStartX, wickStartY); context.quadraticCurveTo(cpX, cpY, wickEndX, wickEndY); context.stroke(); context.lineWidth = 1; return; } if (bubble.type === 'rainbow') { const shimmerOffset = (Date.now() / 15); const grad = context.createLinearGradient(bubble.x - radius, bubble.y - radius, bubble.x + radius, bubble.y + radius); grad.addColorStop(0, `hsl(${(shimmerOffset) % 360}, 100%, 65%)`); grad.addColorStop(0.2, `hsl(${(shimmerOffset + 60) % 360}, 100%, 65%)`); grad.addColorStop(0.4, `hsl(${(shimmerOffset + 120) % 360}, 100%, 65%)`); grad.addColorStop(0.6, `hsl(${(shimmerOffset + 180) % 360}, 100%, 65%)`); grad.addColorStop(0.8, `hsl(${(shimmerOffset + 240) % 360}, 100%, 65%)`); grad.addColorStop(1, `hsl(${(shimmerOffset + 300) % 360}, 100%, 65%)`); context.beginPath(); context.fillStyle = grad; context.arc(bubble.x, bubble.y, radius, 0, Math.PI * 2); context.fill(); } else { const mainColor = bubble.color; context.beginPath(); context.fillStyle=hexToRgba(mainColor, 0.9); context.arc(bubble.x, bubble.y, radius, 0, Math.PI*2); context.fill(); } const hX=bubble.x - radius*0.35, hY=bubble.y - radius*0.35; const highlightGrad=context.createRadialGradient(hX,hY,0,hX,hY,radius*0.7); highlightGrad.addColorStop(0,'rgba(255,255,255,0.8)'); highlightGrad.addColorStop(1,'rgba(255,255,255,0)'); context.fillStyle=highlightGrad; context.beginPath(); context.arc(hX, hY, radius*0.7, 0, Math.PI*2); context.fill(); }
function drawGrid() { for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])drawBubble(ctx,grid[r][c]);}
function drawPopAnimations() { popAnimations.forEach(p=>{const progress=p.life/p.duration;const alpha=1-progress;const currentSize=p.size*(1-progress);ctx.beginPath();ctx.fillStyle=hexToRgba(p.color,alpha);ctx.arc(p.x,p.y,currentSize,0,Math.PI*2);ctx.fill()});}
function drawFloatingPoints() { ctx.font="bold 24px 'Fredoka One',cursive";ctx.textAlign='center';ctx.textBaseline='middle';floatingPoints.forEach(fp=>{const p=fp.life/fp.duration;const alpha=1-p*p;ctx.fillStyle=`rgba(255,255,255,${alpha})`;ctx.strokeStyle=`rgba(60,60,60,${alpha*0.8})`;ctx.lineWidth=4;ctx.strokeText(fp.text,fp.x,fp.y);ctx.fillText(fp.text,fp.x,fp.y)});ctx.lineWidth=1;}
function drawAimingLine() { if(aim.y>playerBubble.y-20)return;const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x);ctx.beginPath();ctx.moveTo(playerBubble.x,playerBubble.y);ctx.lineTo(playerBubble.x+Math.cos(angle)*1e3,playerBubble.y+Math.sin(angle)*1e3);ctx.strokeStyle='rgba(0,0,0,0.3)';ctx.setLineDash([5,10]);ctx.lineWidth=2;ctx.stroke();ctx.setLineDash([]);}
function drawGameOverLine() { ctx.beginPath();ctx.moveTo(0,GAME_OVER_LINE_Y);ctx.lineTo(canvas.width,GAME_OVER_LINE_Y);ctx.strokeStyle='red';ctx.lineWidth=2;ctx.setLineDash([10,5]);ctx.stroke();ctx.setLineDash([]);}
function drawFireworks() { fireworks.forEach(p=>{ctx.beginPath();ctx.fillStyle=p.color;ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill()});}
function drawRain() { ctx.strokeStyle='rgba(174,194,224,0.5)'; ctx.lineWidth=2; rain.forEach(p=>{ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(p.x,p.y+p.len);ctx.stroke()}); ctx.lineWidth=1;}
function drawBombSparks() { bombSparks.forEach(s=>{ctx.fillStyle=s.color;ctx.fillRect(s.x,s.y,2,2)}); }

function initBackgroundBubbles() { for (let i = 0; i < 20; i++) { backgroundBubbles.push({ x: Math.random() * bgCtx.canvas.width, y: Math.random() * bgCtx.canvas.height, radius: Math.random() * 20 + 10, speedY: Math.random() * 0.5 + 0.2, sway: Math.random() * Math.PI * 2, swaySpeed: Math.random() * 0.01 + 0.005, opacity: Math.random() * 0.2 + 0.1 }); } }
function updateBackgroundBubbles() { backgroundBubbles.forEach(b => { b.y -= b.speedY; b.sway += b.swaySpeed; if (b.y + b.radius < 0) { b.y = bgCtx.canvas.height + b.radius; b.x = Math.random() * bgCtx.canvas.width; } }); }
function drawBackgroundBubbles() { bgCtx.clearRect(0, 0, bgCtx.canvas.width, bgCtx.canvas.height); bgCtx.fillStyle = '#aedefc'; bgCtx.fillRect(0, 0, bgCtx.canvas.width, bgCtx.canvas.height); backgroundBubbles.forEach(b => { bgCtx.beginPath(); bgCtx.fillStyle = `rgba(255, 255, 255, ${b.opacity})`; const currentX = b.x + Math.sin(b.sway) * b.radius * 2; bgCtx.arc(currentX, b.y, b.radius, 0, Math.PI * 2); bgCtx.fill(); }); }

async function update() { updatePopAnimations(); updateFloatingPoints(); updateBombSparks(); if(playerBubble?.type === 'bomb') { if(Math.random() < 0.6) { const wickEndX = playerBubble.x + BUBBLE_RADIUS * 0.5, wickEndY = playerBubble.y - BUBBLE_RADIUS * 1.4; bombSparks.push({ x: wickEndX, y: wickEndY, vx: (Math.random()-0.5)*1.5, vy: (Math.random()-0.5)*1.5-0.5, life: 0, duration: 15, color: Math.random()<0.5?'#ffcc00':'#ff9900'}); } } if(isFiring){playerBubble.x+=playerBubble.vx;playerBubble.y+=playerBubble.vy;if(playerBubble.x<BUBBLE_RADIUS||playerBubble.x>canvas.width-BUBBLE_RADIUS)playerBubble.vx*=-1;if(playerBubble.y-BUBBLE_RADIUS<offsetY){snapBubble(null);return}for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c]&&Math.hypot(playerBubble.x-grid[r][c].x,playerBubble.y-grid[r][c].y)<BUBBLE_RADIUS*2){snapBubble({r,c});return}} rowDropTimer++; if(rowDropTimer >= TIME_UNTIL_ROW_DROP){ await addNewRow(); } bombTimer++; if(bombTimer >= BOMB_INTERVAL) { spawnBombBubble(); } }
async function snapBubble(collidedCoords) { isFiring=false;playerBubble.vx=0;playerBubble.vy=0;let s=null; stopSizzle(); stopChimeLoop(); if(collidedCoords===null){let d=Infinity;for(let c=0;c<COLS;c++)if(!grid[0][c]){const D=Math.abs(playerBubble.x-(offsetX+c*HEX_WIDTH));if(D<d){d=D;s={r:0,c}}}} else{const n=getNeighbors(collidedCoords.r,collidedCoords.c);let d=Infinity;for(const N of n)if(!grid[N.r][N.c]){const x=offsetX+N.c*HEX_WIDTH+(N.r%2)*BUBBLE_RADIUS,y=offsetY+N.r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s=N}}} if(s===null){let d=Infinity;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(!grid[r][c]&&!(r%2===1&&c===COLS-1)){const x=offsetX+c*HEX_WIDTH+(r%2)*BUBBLE_RADIUS,y=offsetY+r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s={r,c}}}} if(s){ if (playerBubble.type === 'rainbow') { await handleRainbowSnap(s.r, s.c); } else { grid[s.r][s.c]=createBubble(s.r,s.c,playerBubble.color,playerBubble.type); await handlePostSnap(s.r,s.c); } }else{prepareNextShot()} }
function prepareNextShot() { if(gameState!=='playing')return; stopSizzle(); stopChimeLoop(); playerBubble={...nextBubble,x:canvas.width/2,y:canvas.height-BUBBLE_RADIUS}; if(playerBubble.type==='rainbow'){ playSound('chimeLoopStart'); } else if(playerBubble.type === 'bomb'){ playSound('sizzleStart'); } nextBubble=generateNextBubble(); updateUI(); }

function endGame(isWinner) { gameState='gameover'; isFiring=false; stopSizzle(); stopChimeLoop(); let finalScore = score; const currentHighScore = getHighScore(); if(isWinner && isGridEmpty()){ finalScore += 5000; } if (finalScore > currentHighScore) { saveHighScore(finalScore); defaultEndMessageEl.style.display = 'none'; newHighScoreMessageEl.style.display = 'block'; newHighScoreValueEl.innerText = finalScore; currentHighScoreEl.innerText = finalScore; setTimeout(() => createFirework(true), 100); setTimeout(() => createFirework(true), 500); setTimeout(() => createFirework(true), 900); } else { defaultEndMessageEl.style.display = 'block'; newHighScoreMessageEl.style.display = 'none'; if(isWinner) { endMessageEl.innerText = 'You Win!'; createFirework(); } else { endMessageEl.innerText = 'Sorry, you lost!'; createRain(); } finalScoreEl.innerText = finalScore; highScoreEl.innerText = currentHighScore; } gameOverEl.style.display='flex'; }
function createFirework(isBig=false) { const x=Math.random()*canvas.width*0.8+canvas.width*0.1; const y=Math.random()*canvas.height*0.5+canvas.height*0.1; const color=`hsl(${Math.random()*360},100%,50%)`; const particleCount = isBig ? 120 : 50; const speedMultiplier = isBig ? 1.4 : 1; const sizeMultiplier = isBig ? 1.6 : 1; for(let i=0; i < particleCount; i++){ const angle=Math.random()*Math.PI*2; const speed=(Math.random()*3+1) * speedMultiplier; fireworks.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,color,size:(Math.random()*2+1) * sizeMultiplier}) } }

function setupAudio() { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
document.getElementById('continue-button').addEventListener('click',()=>{setupAudio();rulesOverlay.style.display='none';startOverlay.style.display='flex'});
document.getElementById('play-button').addEventListener('click',()=>{setupAudio();startOverlay.style.display='none';gameState='playing'});
document.getElementById('play-again-button').addEventListener('click',()=>{gameOverEl.style.display='none';init();startOverlay.style.display='flex'});
document.getElementById('restart-button').addEventListener('click',()=>{if(gameState==='playing'&&confirm('Are you sure you want to restart the game?')){init();startOverlay.style.display='flex'}else if(gameState!=='playing'){init();startOverlay.style.display='flex'}});
document.getElementById('sound-toggle-button').addEventListener('click', () => { isMuted = !isMuted; document.getElementById('sound-toggle-button').innerText = isMuted ? 'Sound OFF' : 'Sound ON'; if(isMuted) { stopSizzle(); stopChimeLoop(); } else { setupAudio(); if(playerBubble?.type === 'rainbow') playSound('chimeLoopStart'); if(playerBubble?.type === 'bomb') playSound('sizzleStart'); } });
const isMobile = 'ontouchstart' in window;
if(isMobile){canvas.addEventListener('touchmove',e=>{e.preventDefault();handleAimUpdate(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});canvas.addEventListener('touchend',e=>{e.preventDefault();handleFire()},{passive:false})}else{canvas.addEventListener('mousemove',e=>{handleAimUpdate(e.clientX,e.clientY)});canvas.addEventListener('click',handleFire)}

function handleAimUpdate(clientX,clientY) { 
    if(gameState!=='playing' || isFiring) return; 
    const rect=canvas.getBoundingClientRect(); 
    aim.x=(clientX-rect.left)*(canvas.width/rect.width); 
    aim.y=(clientY-rect.top)*(canvas.height/rect.height);
    const currentAngle = Math.atan2(aim.y - playerBubble.y, aim.x - playerBubble.x);
    const currentStep = Math.floor(currentAngle / AIM_TICK_ANGLE_STEP);
    if (currentStep !== lastAimStep) {
        playSound('tick');
        lastAimStep = currentStep;
    }
}
function handleFire() { if(gameState!=='playing'||isFiring||aim.y>playerBubble.y-20)return; playSound('launch'); const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x),speed=15;playerBubble.vx=Math.cos(angle)*speed;playerBubble.vy=Math.sin(angle)*speed;isFiring=true;}

function gameLoop() { updateBackgroundBubbles(); drawBackgroundBubbles(); if (gameState === 'playing') update(); if (gameState === 'gameover') { if (fireworks.length > 0) updateFireworks(); if (rain.length > 0) updateRain(); } ctx.clearRect(0,0,canvas.width,canvas.height); drawGrid(); if(gameState==='playing')drawBubble(ctx,playerBubble); if(gameState==='playing'&&!isFiring)drawAimingLine(); drawPopAnimations(); drawFloatingPoints(); drawBombSparks(); drawGameOverLine(); if(gameState === 'gameover') { drawFireworks(); drawRain(); } requestAnimationFrame(gameLoop); }

// --- Unchanged Functions ---
function updatePopAnimations() { for(let i=popAnimations.length-1;i>=0;i--){const p=popAnimations[i];p.life++;p.x+=p.vx;p.y+=p.vy;p.vx*=0.97;p.vy*=0.97;if(p.life>=p.duration){popAnimations.splice(i,1)}}}
function updateFloatingPoints() { for(let i=floatingPoints.length-1;i>=0;i--){const fp=floatingPoints[i];fp.life++;fp.y+=fp.vy;if(fp.life>=fp.duration){floatingPoints.splice(i,1)}}}
function updateFireworks() { for(let i=fireworks.length-1;i>=0;i--){const p=fireworks[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.02;p.size*=0.98;if(p.size<0.5)fireworks.splice(i,1)} if(gameState !== 'gameover' && Math.random()<0.05)createFirework();}
function updateRain() { for(let i=rain.length-1;i>=0;i--){const p=rain[i];p.y+=p.speed;if(p.y>canvas.height){p.y=-p.len;p.x=Math.random()*canvas.width}};}
function updateBombSparks() { for(let i=bombSparks.length-1;i>=0;i--){const s=bombSparks[i];s.life++;s.x+=s.vx;s.y+=s.vy;if(s.life>=s.duration)bombSparks.splice(i,1)}}
function createFloatingPoints(text, x, y) { floatingPoints.push({text,x,y,life:0,duration:FLOATING_POINTS_DURATION,vy:-0.7});}
function createPopEffect(x, y, color) { for(let i=0;i<POP_PARTICLE_COUNT;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*2+1;popAnimations.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:0,duration:POP_PARTICLE_DURATION,color:color||'#ccc',size:Math.random()*5+3});}}
function popBubbles(bubblesToPop) { bubblesToPop.forEach(b=>{if(grid[b.r]?.[b.c]){const bubble=grid[b.r][b.c];createPopEffect(bubble.x,bubble.y,bubble.color);grid[b.r][b.c]=null}});}
function dropBubbles(bubblesToDrop) { popBubbles(bubblesToDrop); }
async function handlePostSnap(row, col) { let popsOccurred = false; const landedBubble = grid[row][col]; if (landedBubble && landedBubble.type === 'bomb') { popsOccurred = handleBombExplosion(row, col); } else { const matches = findMatches(row, col); if (matches.length >= 3) { popsOccurred = true; const points = matches.length * 50; score += points; const matchedBubbles = matches.map(coord => grid[coord.r]?.[coord.c]).filter(b => b); const lifeBubblePopped = matchedBubbles.some(b => b.type === 'life'); if(matchedBubbles[0]) createFloatingPoints(`+${points}`, matchedBubbles[0].x, matchedBubbles[0].y); popBubbles(matches); if (lifeBubblePopped) { shotsFired = Math.max(0, shotsFired - 1); createFloatingPoints('-1 Miss!', canvas.width / 2, canvas.height / 2); playSound('lifeGet'); } } } if (popsOccurred) { playSound('pop'); const floating = await findFloatingBubbles(); if (floating.length > 0) { const points = floating.length * 100; score += points; let lifeBubblesDropped = 0; let centerX = 0, centerY = 0, bubbleCount = 0; floating.forEach(coord => { const bubbleData = grid[coord.r]?.[coord.c]; if (bubbleData) { centerX += bubbleData.x; centerY += bubbleData.y; bubbleCount++; if (bubbleData.type === 'life') { lifeBubblesDropped++; } } }); if (lifeBubblesDropped > 0) { shotsFired = Math.max(0, shotsFired - lifeBubblesDropped); createFloatingPoints(`- ${lifeBubblesDropped} Miss!`, canvas.width / 2, canvas.height / 2); playSound('lifeGet'); } if (bubbleCount > 0) createFloatingPoints(`+${points}`, centerX / bubbleCount, centerY / bubbleCount); dropBubbles(floating); } } else { shotsFired++; } updateUI(); if(isGridEmpty()){ endGame(true); return; } for (let c=0; c<COLS; c++) if (grid[ROWS-1][c]){ endGame(false); return; } if (shotsFired >= SHOTS_UNTIL_LOSS) { endGame(false); return; } prepareNextShot();}
async function handleRainbowSnap(r, c) { const neighbors = getNeighbors(r, c); const coloredNeighbor = neighbors.find(n => grid[n.r]?.[n.c] && grid[n.r][n.c].type === 'normal'); if (coloredNeighbor) { const newColor = grid[coloredNeighbor.r][coloredNeighbor.c].color; grid[r][c] = createBubble(r, c, newColor, 'normal'); await handlePostSnap(r, c); } else { createPopEffect(offsetX+c*HEX_WIDTH+(r%2)*BUBBLE_RADIUS, offsetY+r*HEX_HEIGHT, '#cccccc'); shotsFired++; updateUI(); if (shotsFired >= SHOTS_UNTIL_LOSS) { endGame(false); return; } prepareNextShot(); }}
function handleBombExplosion(row, col) { playSound('explosion'); const explosionCenter = { x: offsetX + col * HEX_WIDTH + (row % 2) * BUBBLE_RADIUS, y: offsetY + row * HEX_HEIGHT }; const explosionRadius = BUBBLE_RADIUS * 4.18; let bubblesToPop = []; let points = 0; let lifeBubblesPopped = 0; for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) { const bubble = grid[r][c]; if (bubble) { const dist = Math.hypot(bubble.x - explosionCenter.x, bubble.y - explosionCenter.y); if (dist <= explosionRadius) { if (bubble.type === 'life') { lifeBubblesPopped++; } bubblesToPop.push({r, c}); points += 50; }}}} if (bubblesToPop.length > 0) { if (lifeBubblesPopped > 0) { shotsFired = Math.max(0, shotsFired - lifeBubblesPopped); createFloatingPoints(`- ${lifeBubblesPopped} Miss!`, canvas.width / 2, canvas.height / 2); playSound('lifeGet'); } score += points; createFloatingPoints(`+${points}`, explosionCenter.x, explosionCenter.y); popBubbles(bubblesToPop); createExplosionEffect(explosionCenter.x, explosionCenter.y); return true; } return false;}
function createExplosionEffect(x, y) { for(let i=0;i<40;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*4+2;popAnimations.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:0,duration:POP_PARTICLE_DURATION+20,color:Math.random()<0.5?'orange':'red',size:Math.random()*6+4});}}
async function addNewRow() { for(let c = 0; c < COLS; c++) { if(grid[ROWS - 2]?.[c]) { endGame(false); return; } } for(let r=ROWS-2;r>=0;r--)for(let c=0;c<COLS;c++)if(grid[r][c]){grid[r+1][c]=grid[r][c];grid[r+1][c].row=r+1;grid[r+1][c].x=offsetX+c*HEX_WIDTH+((r+1)%2)*BUBBLE_RADIUS;grid[r+1][c].y=offsetY+(r+1)*HEX_HEIGHT}else grid[r+1][c]=null; for(let c=0;c<COLS;c++)grid[0][c]=createBubble(0,c); const topRowBubbles = []; for(let c=0; c<COLS; c++) { if(grid[0][c]) { topRowBubbles.push(c); } } if(topRowBubbles.length > 0) { const randomCol = topRowBubbles[Math.floor(Math.random() * topRowBubbles.length)]; grid[0][randomCol].type = 'life'; grid[0][randomCol].color = '#ffffff';} rowDropTimer=0; const floating = await findFloatingBubbles(); if(floating.length > 0) { const points = floating.length * 100; score += points; let lifeBubblesDropped = 0; let centerX=0,centerY=0,bubbleCount=0; floating.forEach(coord => {const bubbleData=grid[coord.r]?.[coord.c];if(bubbleData){centerX+=bubbleData.x;centerY+=bubbleData.y;bubbleCount++; if (bubbleData.type === 'life') { lifeBubblesDropped++; } }}); if (lifeBubblesDropped > 0) { shotsFired = Math.max(0, shotsFired - lifeBubblesDropped); createFloatingPoints(`- ${lifeBubblesDropped} Miss!`, canvas.width / 2, canvas.height / 2); playSound('lifeGet'); } if(bubbleCount>0)createFloatingPoints(`+${points}`,centerX/bubbleCount,centerY/bubbleCount);dropBubbles(floating); updateUI(); }}
function spawnBombBubble() { nextBubble = { type: 'bomb', color: '#444' }; updateUI(); bombTimer = 0; }
function getNeighbors(r,c) { const p=r%2,d=[{dr:0,dc:1},{dr:0,dc:-1},{dr:-1,dc:p-1},{dr:-1,dc:p},{dr:1,dc:p-1},{dr:1,dc:p}],n=[];for(const i of d){const nr=r+i.dr,nc=c+i.dc;if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS&&!(nr%2===1&&nc===COLS-1))n.push({r:nr,c:nc})}return n}
function findMatches(startR, startC) { const startBubble = grid[startR][startC]; if (!startBubble) return []; let potentialMatches = new Map(); let toVisit = [{ r: startR, c: startC }]; let visited = new Set([`${startR},${startC}`]); while (toVisit.length > 0) { const current = toVisit.shift(); const bubble = grid[current.r][current.c]; getNeighbors(current.r, current.c).forEach(nCoord => { const neighbor = grid[nCoord.r]?.[nCoord.c]; if (neighbor && !visited.has(`${nCoord.r},${nCoord.c}`)) { if (neighbor.type === 'life') { visited.add(`${nCoord.r},${nCoord.c}`); toVisit.push(nCoord); } else if (bubble.type === 'life' || neighbor.color === bubble.color) { visited.add(`${nCoord.r},${nCoord.c}`); toVisit.push(nCoord); } } }); } visited.forEach(coordStr => { const [r, c] = coordStr.split(',').map(Number); const bubble = grid[r][c]; if (bubble.type !== 'life') { if (!potentialMatches.has(bubble.color)) { potentialMatches.set(bubble.color, []); } potentialMatches.get(bubble.color).push({ r, c }); } }); const lifeBubbles = Array.from(visited).filter(coordStr => { const [r, c] = coordStr.split(',').map(Number); return grid[r][c]?.type === 'life'; }).map(coordStr => { const [r, c] = coordStr.split(',').map(Number); return {r,c}; }); for (const [color, bubbles] of potentialMatches.entries()) { if (bubbles.length + lifeBubbles.length >= 3) { return [...bubbles, ...lifeBubbles]; } } return [];}
async function findFloatingBubbles() { await new Promise(r => setTimeout(r, 10)); const o=new Set(),q=[];for(let c=0;c<COLS;c++)if(grid[0][c]){q.push({r:0,c:c});o.add(`0,${c}`)}let h=0;while(h<q.length){const u=q[h++];for(const n of getNeighbors(u.r,u.c))if(grid[n.r][n.c]&&!o.has(`${n.r},${n.c}`)){o.add(`${n.r},${n.c}`);q.push(n)}}const f=[];for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c]&&!o.has(`${r},${c}`))f.push({r,c});return f}
function isGridEmpty() { for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])return false; return true;}
function createRain() { for(let i=0;i<100;i++){rain.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,len:Math.random()*20+10,speed:Math.random()*5+2})}}

// Kick off the game
init(); 
initBackgroundBubbles();
gameLoop();

</script>
</body>
</html>
