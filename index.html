<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pop! Pop! Bubble Stop! - Level Up!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html {
            height: 100%;
        }
        body {
            background: radial-gradient(circle, #5c97bf, #1c3d5a);
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden; /* Hide scrollbars caused by background bubbles */
        }
        
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* This is crucial to place it behind everything */
        }

        h1 {
            margin-bottom: 10px;
            font-family: 'Fredoka One', cursive;
            font-size: 2.5em;
            color: white;
            text-shadow: 2px 2px 4px #4a2d6b;
            position: relative; 
            z-index: 2;
            text-align: center;
            max-width: 95vw; /* Prevent overflow on small screens */
        }

        #game-container {
            position: relative;
            aspect-ratio: 500 / 600;
            width: 500px; /* Define ideal width */
            max-width: 90vw; /* Shrink on small viewports */
            max-height: 75vh; /* Prevent it from being too tall on certain screens */
            height: auto; /* Height is now determined by width + aspect-ratio */
            
            background-color: rgba(214, 232, 250, 0.65); /* Semi-transparent */
            backdrop-filter: blur(4px); /* Frosted glass effect */
            border: 5px solid rgba(163, 193, 227, 0.7); /* Semi-transparent border */
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            border-radius: 10px;
            z-index: 1;
            transition: background-color 0.5s ease; /* Smooth background transition */
        }

        canvas {
            display: block;
            background-color: transparent;
            width: 100%;
            height: 100%;
            border-radius: 5px; /* Match container's inner radius */
        }
        
        #ui-container {
            width: 500px;
            max-width: 90vw;
            margin-top: 15px;
            padding: 10px;
            box-sizing: border-box;
            background-color: rgba(214, 232, 250, 0.65); /* Semi-transparent */
            backdrop-filter: blur(4px); /* Frosted glass effect */
            border: 5px solid rgba(163, 193, 227, 0.7); /* Semi-transparent border */
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on medium screens */
            gap: 10px;
            color: #4a2d6b;
            font-size: 18px;
            font-weight: bold;
            z-index: 1;
        }

        #restart-button, #audio-toggle-button {
            padding: 5px 10px; font-size: 14px; font-weight: bold; cursor: pointer;
            border: 2px solid #4a2d6b; background-color: white; color: #4a2d6b; border-radius: 5px;
        }
        .next-bubble-area {
            display: flex; align-items: center; gap: 8px;
        }

        .overlay-screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            color: white;
            display: flex; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.5em;
            border-radius: 5px; /* Match inner radius of container */
            z-index: 10; /* Ensure overlays are on top */
        }
        .overlay-screen h2 {
            font-family: 'Fredoka One', cursive; margin-top: 0; margin-bottom: 20px;
            font-size: 1.8em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .overlay-screen button {
            margin-top: 20px; padding: 15px 30px;
            font-size: 1em; font-weight: bold; font-family: 'Fredoka One', cursive;
            cursor: pointer; border: 2px solid white; background-color: #8c6ba9;
            color: white; border-radius: 10px; transition: transform 0.1s ease;
        }
        .overlay-screen button:hover { transform: scale(1.05); }

        #rules-overlay ul { list-style: none; padding: 0; margin: 0; font-size: 0.7em; max-width: 80%;}
        #rules-overlay li { margin-bottom: 15px; }
        #game-over { display: none; }
        #start-overlay { display: none; }
        #level-up-overlay { display: none; }
        #level-up-overlay p { font-size: 0.8em; margin: 10px 0 20px 0; }


        /* Responsive UI for Mobile */
        @media (max-width: 480px) {
            h1 {
                font-size: 2em;
            }
            #ui-container {
                justify-content: center; /* Center items for a better look when wrapped */
                font-size: 16px; /* Slightly smaller font to help with wrapping */
                gap: 8px;
            }
            #restart-button, #audio-toggle-button {
                padding: 10px 15px; /* Bigger button for easier tapping */
            }
        }

    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>

    <h1>Pop! Pop! Bubble Stop!</h1>
    <div id="game-container">
        <canvas id="gameCanvas" width="500" height="600"></canvas>
        <div id="rules-overlay" class="overlay-screen">
            <h2>How to Play</h2>
            <ul>
                <li>Match 3+ bubbles to score.</li>
                <li>Clear all bubbles to level up instantly!</li>
                <li>Level up by reaching score milestones!</li>
                <li>A powerful Bomb Bubble may appear to clear a large area!</li>
                <li>An extra life bubble may appear. Pop it to remove a miss!</li>
                <li>5 misses and you lose!</li>
            </ul>
            <button id="continue-button">Continue</button>
        </div>
        <div id="level-up-overlay" class="overlay-screen">
            <h2 id="level-up-title">Level Up!</h2>
            <p id="level-up-message">Congratulations! Get ready for the next challenge.</p>
            <button id="level-up-continue-button">Continue</button>
        </div>
        <div id="start-overlay" class="overlay-screen"> <button id="play-button">Play!</button> </div>
        <div id="game-over" class="overlay-screen">
            <h2 id="end-message">Game Over</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="play-again-button">Play Again</button>
        </div>
    </div>
    
    <div id="ui-container">
        <div>Level: <span id="level">1</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>High Score: <span id="high-score">0</span></div>
        <div>Misses: <span id="miss-counter">0</span>/5</div>
        <div class="next-bubble-area">
            <span>Next:</span>
            <canvas id="nextBubbleCanvas" width="40" height="40"></canvas>
        </div>
        <button id="audio-toggle-button">Sound: ON</button>
        <button id="restart-button">Restart</button>
    </div>

<script>
// --- Game Setup & Constants ---
const bgCanvas = document.getElementById('backgroundCanvas'), bgCtx = bgCanvas.getContext('2d');
const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');
const nextBubbleCanvas = document.getElementById('nextBubbleCanvas'), nextCtx = nextBubbleCanvas.getContext('2d');
const scoreEl = document.getElementById('score'), levelEl = document.getElementById('level'), gameOverEl = document.getElementById('game-over');
const highScoreEl = document.getElementById('high-score');
const missCounterEl = document.getElementById('miss-counter');
const finalScoreEl = document.getElementById('finalScore'), rulesOverlay = document.getElementById('rules-overlay');
const startOverlay = document.getElementById('start-overlay'), endMessageEl = document.getElementById('end-message');
const levelUpOverlay = document.getElementById('level-up-overlay'), levelUpMessageEl = document.getElementById('level-up-message');
const audioToggleButton = document.getElementById('audio-toggle-button');

const COLS = 12, ROWS = 14, SHOTS_UNTIL_LOSS = 5;
const BOMB_INTERVAL = 25 * 60; // Bomb every 25 seconds
const LEVEL_ROW_DROP_SPEEDS = {
    1: 15 * 60, // Level 1: 15 seconds
    2: 12 * 60, // Level 2: 12 seconds
    3: 8 * 60   // Level 3: 8 seconds
};
const FLOATING_POINTS_DURATION = 75, POP_PARTICLE_COUNT = 8, POP_PARTICLE_DURATION = 40;
const PADDING = 5;
const BUBBLE_RADIUS = (canvas.width - PADDING * 2) / (COLS * 2 + 1);
const HEX_WIDTH = BUBBLE_RADIUS * 2, HEX_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS;
const offsetX = PADDING + BUBBLE_RADIUS, offsetY = PADDING + BUBBLE_RADIUS;
const GAME_OVER_LINE_Y = canvas.height - BUBBLE_RADIUS * 4;

const ALL_COLORS = {
    // Level 1: Bright & Primary
    1: ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF', '#FFFF33'],
    // Level 2: New "Easter" Pastel Palette - Bright, clear, and distinct
    2: ['#FFC4E1', '#A1C9F4', '#B2F7C3', '#FFF7AE', '#D9BFF5', '#FFD8B1'], // Pink, Blue, Green, Yellow, Purple, Orange
    // Level 3: New Metallic Palette - Rich, distinct hues
    3: ['#FFD700', '#C0C0C0', '#CD7F32', '#6A738B', '#50C878', '#E39695'] // Gold, Silver, Bronze, Steel Blue, Emerald, Rose Gold
};

const LEVEL_RAINBOW_COLORS = {
    1: ['#FF5733', '#FFFF33', '#33FF57', '#3357FF', '#A133FF'], // Classic Rainbow
    2: ['#FFC4E1', '#FFF7AE', '#B2F7C3', '#A1C9F4', '#D9BFF5'], // Pastel Rainbow
    3: ['#FFD700', '#E39695', '#50C878', '#6A738B', '#C0C0C0']  // Metallic Rainbow
};

const LEVEL_UP_SCORES = { 1: 3500, 2: 8500 };
const LEVEL_BACKGROUNDS = {
    1: 'rgba(214, 232, 250, 0.65)', // Original light blue
    2: 'rgba(50, 60, 90, 0.7)',     // Dark navy for pastels
    3: 'rgba(80, 75, 70, 0.75)'      // Dark warm grey for metallics
};
const MAX_LEVEL = 3;
const SPECIALS = { 'RAINBOW': 'rainbow', 'LIFE': 'life', 'BOMB': 'bomb' };
const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);

// --- Audio Engine ---
let audioContext;
const sounds = {};
let lastAimAngle = 0;
let audioInitialized = false;
let isMuted = false;
let sizzleSoundSource = null, rainbowSoundSource = null;
let aimClickCounter = 0;

async function initAudio() {
    if (audioInitialized || audioContext) return;
    audioInitialized = true;
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') { await audioContext.resume(); }
        await createAllSounds();
    } catch (e) { console.error("Web Audio API failed to initialize.", e); }
}

function playSound(name, options = {}) {
    if (isMuted || !audioContext || !sounds[name]) return;
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(options.gain !== undefined ? options.gain : 0.5, audioContext.currentTime);
    source.connect(gainNode).connect(audioContext.destination);
    source.start(0);
}

function playLoopingSound(name, options = {}) {
    if (isMuted || !audioContext || !sounds[name]) return null;
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    source.loop = true;
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(options.gain !== undefined ? options.gain : 0.4, audioContext.currentTime);
    source.connect(gainNode).connect(audioContext.destination);
    source.start(0);
    return source;
}

function stopLoopingSound(source) {
    if (source) {
        source.stop();
    }
    return null;
}

const soundGenerators = {
    click: async actx => { const d=0.05,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=Math.sin(6.28*2e3*p)*Math.pow(1-p,4)}return b;},
    shick: async actx => { const d=0.08,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++)c[i]=(Math.random()*2-1)*Math.pow(1-i/c.length,10);const o=new OfflineAudioContext(1,actx.sampleRate*d,actx.sampleRate),s=o.createBufferSource();s.buffer=b;const h=o.createBiquadFilter();h.type='highpass';h.frequency.value=1500;const p=o.createBiquadFilter();p.type='bandpass';p.frequency.value=4e3;p.Q.value=1.5;s.connect(h).connect(p).connect(o.destination);s.start();return await o.startRendering();},
    shoot: async actx => { const d=0.2,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=(Math.random()*2-1)*Math.pow(1-p,2)*.3+Math.sin(6.28*(2e3-p*1800)*p)*Math.pow(1-p,2)*.7}return b;},
    pop: async actx => { const d = 0.15, o = new OfflineAudioContext(1, actx.sampleRate * d, actx.sampleRate); const t = o.currentTime; const osc = o.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.08); const oscGain = o.createGain(); oscGain.gain.setValueAtTime(0.7, t); oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.08); osc.connect(oscGain); const noiseDur = 0.02; const noiseBuf = actx.createBuffer(1, actx.sampleRate * noiseDur, actx.sampleRate); const noiseData = noiseBuf.getChannelData(0); for (let i = 0; i < noiseData.length; i++) noiseData[i] = Math.random() * 2 - 1; const noise = o.createBufferSource(); noise.buffer = noiseBuf; const noiseGain = o.createGain(); noiseGain.gain.setValueAtTime(0.1, t + 0.06); noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.06 + noiseDur); noise.connect(noiseGain); const lowpass = o.createBiquadFilter(); lowpass.type = 'lowpass'; lowpass.frequency.value = 800; oscGain.connect(lowpass); noiseGain.connect(lowpass); lowpass.connect(o.destination); osc.start(t); noise.start(t + 0.06); return await o.startRendering(); },
    bomb: async actx => { const d=0.8,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=(Math.random()*2-1)*Math.pow(1-p,4)+Math.sin(6.28*100*Math.pow(1-p,2)*p)*Math.pow(1-p,2)}return b;},
    life: async actx => { const d=0.3,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0),n1=Math.floor(actx.sampleRate*.1),n2=Math.floor(actx.sampleRate*.12);for(let i=0;i<n1;i++){const p=i/n1;c[i]=Math.sin(6.28*523.25*(i/actx.sampleRate))*Math.pow(1-p,2)*.8}for(let i=n2;i<c.length;i++){const p=(i-n2)/(c.length-n2);c[i]+=Math.sin(6.28*783.99*((i-n2)/actx.sampleRate))*Math.pow(1-p,2)*.8}return b;},
    levelUp: async actx => { const d=.1,n=[261.63,329.63,392,523.25],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,1.5)}}return b;},
    win: async actx => { const d=.12,n=[523.25,659.25,783.99,1046.5,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*(d*n.length+.2),actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*(1-p)*.8}}return b;},
    lose: async actx => { const d=.25,n=[440,349.23,261.63,196],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,.5)*.7}}return b;},
    sizzle: async actx => { const d=1,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){c[i]=(Math.random()*2-1)*.4}const f=actx.createBiquadFilter();f.type='bandpass';f.frequency.value=2e3;f.Q.value=.5;const s=actx.createBufferSource();s.buffer=b;s.connect(f);const dest=actx.createMediaStreamDestination();f.connect(dest);return b;},
    rainbow: async actx => { const d=.15,n=[523.25,659.25,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,2)*.8}}return b;},
};

async function createAllSounds() {
    const promises = Object.keys(soundGenerators).map(async name => {
        sounds[name] = await soundGenerators[name](audioContext);
    });
    await Promise.all(promises);
}

// --- Game State ---
let grid, playerBubble, nextBubble, score, highScore, shotsFired, rowDropTimer, bombTimer, newRowsDropped;
let isFiring = false, aim = { x: canvas.width / 2, y: 0 };
let popAnimations = [], floatingPoints = [], fireworks = [], rain = [], bombSparks = [], shockwaves = [];
let gameState = 'rules';
let backgroundBubbles = [];
let level, currentColors, rainbowGradientOffset;

// New function to update level-specific visuals
function updateLevelStyles(newLevel) {
    if (gameContainer && LEVEL_BACKGROUNDS[newLevel]) {
        gameContainer.style.backgroundColor = LEVEL_BACKGROUNDS[newLevel];
    }
}

function hexToRgba(hex, alpha) { if(!hex) return `rgba(0,0,0,${alpha})`; const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return r?`rgba(${parseInt(r[1],16)},${parseInt(r[2],16)},${parseInt(r[3],16)},${alpha})`:`rgba(0,0,0,${alpha})`;}
function darkenColor(hex, percent) { if (!hex) return '#000000'; let f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF; return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);}
function createBubble(row, col, color=null, type='normal') { if(color===null)color=currentColors[Math.floor(Math.random()*currentColors.length)]; const x = offsetX + col*HEX_WIDTH + (row%2)*BUBBLE_RADIUS; const y = offsetY + row*HEX_HEIGHT; return {row,col,x,y,color,type,vx:0,vy:0};}
function generateNextBubble() { let color = currentColors[Math.floor(Math.random()*currentColors.length)], type='normal'; if(Math.random()<0.05){type=SPECIALS.RAINBOW;color=null} return {x:canvas.width/2,y:canvas.height-BUBBLE_RADIUS,color,type,vx:0,vy:0};}

function resetForNextLevel() {
    grid = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
    shotsFired = 0; // Reset miss counter for the new level
    isFiring = false;
    rowDropTimer = 0; bombTimer = 0; aimClickCounter = 0; newRowsDropped = 0;
    popAnimations = []; floatingPoints = []; fireworks = []; rain = []; bombSparks = []; shockwaves = [];

    const initialPaletteSize = Math.min(currentColors.length, 4);
    const initialColorPalette = currentColors.slice(0, initialPaletteSize);

    for (let r = 0; r < 4; r++) {
        for (let c = 0; c < COLS; c++) {
            const randomColor = initialColorPalette[Math.floor(Math.random() * initialColorPalette.length)];
            grid[r][c] = createBubble(r, c, randomColor);
        }
    }

    const midPoint = Math.floor(COLS / 2);
    const r1 = Math.floor(Math.random() * 2);
    const c1 = Math.floor(Math.random() * midPoint);
    const r2 = Math.floor(Math.random() * 2);
    const c2 = midPoint + Math.floor(Math.random() * (COLS - midPoint));
    grid[r1][c1] = createBubble(r1, c1, '#ffffff', 'life');
    grid[r2][c2] = createBubble(r2, c2, '#ffffff', 'life');

    playerBubble = generateNextBubble();
    nextBubble = generateNextBubble();
    updateUI();
}

function init() {
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    score=0; shotsFired=0;
    highScore = parseInt(localStorage.getItem('bubblePopHighScore')) || 0;
    level = 1;
    updateLevelStyles(level);
    currentColors = ALL_COLORS[level];
    rainbowGradientOffset = 0;
    resetForNextLevel();
    gameState = 'pregame';
    updateUI();
}

function updateUI() { 
    scoreEl.innerText=score; 
    highScoreEl.innerText = highScore;
    levelEl.innerText = level;
    missCounterEl.innerText = shotsFired; 
    nextCtx.clearRect(0,0,nextBubbleCanvas.width,nextBubbleCanvas.height); 
    drawBubble(nextCtx,{...nextBubble,x:nextBubbleCanvas.width/2,y:nextBubbleCanvas.height/2,radius:BUBBLE_RADIUS*0.8});
}

// --- Drawing Functions ---
function draw3DSphere(context, x, y, radius, baseStyle) {
    const opacity = (level > 1) ? 0.80 : 0.65;
    if (typeof baseStyle === 'string') { context.fillStyle = hexToRgba(baseStyle, opacity); } else { context.fillStyle = baseStyle; }
    context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let glowGrad = context.createRadialGradient(x, y, 0, x, y, radius);
    glowGrad.addColorStop(0, 'rgba(255, 255, 255, 0.2)'); glowGrad.addColorStop(0.8, 'rgba(255, 255, 255, 0)');
    context.fillStyle = glowGrad; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let shadowGrad = context.createRadialGradient(x + radius * 0.4, y + radius * 0.5, radius * 0.5, x, y, radius * 1.5);
    shadowGrad.addColorStop(0, 'rgba(0,0,0,0.3)'); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = shadowGrad; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let highlightGrad = context.createRadialGradient(x - radius * 0.4, y - radius * 0.5, 0, x - radius * 0.4, y - radius * 0.5, radius * 0.6);
    highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)'); highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    context.fillStyle = highlightGrad; context.beginPath(); context.arc(x - radius * 0.4, y - radius * 0.5, radius * 0.6, 0, Math.PI * 2); context.fill();
}
function drawBubble(context, bubble) {
    if (!bubble) return;
    const radius = bubble.radius || BUBBLE_RADIUS, x = bubble.x, y = bubble.y;
    if (bubble.type === 'life') {
        draw3DSphere(context, x, y, radius, '#FFFFFF');
        context.strokeStyle = '#D00000'; context.lineWidth = 4; const plusSize = radius * 0.5; context.beginPath();
        context.moveTo(x, y - plusSize); context.lineTo(x, y + plusSize);
        context.moveTo(x - plusSize, y); context.lineTo(x + plusSize, y);
        context.stroke(); context.lineWidth = 1; return;
    }
    if (bubble.type === 'bomb') {
        context.fillStyle = '#222222';
        context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
        let shadowGrad = context.createRadialGradient(x + radius * 0.4, y + radius * 0.5, radius * 0.5, x, y, radius * 1.5);
        shadowGrad.addColorStop(0, 'rgba(0,0,0,0.4)'); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = shadowGrad; context.fill();
        let highlightGrad = context.createRadialGradient(x - radius * 0.4, y - radius * 0.5, 0, x - radius * 0.4, y - radius * 0.5, radius * 0.6);
        highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.1)'); highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        context.fillStyle = highlightGrad; context.fill();
        const capHeight = radius * 0.4, capWidth = radius * 0.55, capY = y - radius * 0.8, capX = x - capWidth / 2;
        context.fillStyle = '#888888'; context.fillRect(capX, capY - capHeight, capWidth, capHeight);
        context.fillStyle = '#AAAAAA'; context.fillRect(capX, capY - capHeight, capWidth, capHeight * 0.3);
        const fuseBaseY = capY - capHeight, fuseLength = radius * 0.8, fuseTipY = fuseBaseY - fuseLength;
        context.strokeStyle = '#A5694B'; context.lineWidth = 3;
        context.beginPath(); context.moveTo(x, fuseBaseY); context.lineTo(x, fuseTipY); context.stroke();
        context.lineWidth = 1;
        if (bubble === playerBubble && !isFiring) {
            if (Math.random() < 0.7) {
                bombSparks.push({ x: x, y: fuseTipY, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2 - 1.5, life: 0, duration: 20, color: Math.random() < 0.5 ? 'yellow' : 'orange' });
            }
        }
        return;
    }
    if (bubble.type === 'rainbow') {
        let rainbowGrad = context.createLinearGradient(x - radius, y - radius, x + radius, y + radius);
        const colors = LEVEL_RAINBOW_COLORS[level] || LEVEL_RAINBOW_COLORS[1]; // Use level-specific rainbow, fallback to 1
        const numColors = colors.length;
        for (let i = 0; i <= numColors * 2; i++) {
            const colorIndex = i % numColors;
            let position = (i / numColors + rainbowGradientOffset) % 1;
            rainbowGrad.addColorStop(position, colors[colorIndex]);
        }
        draw3DSphere(context, x, y, radius, rainbowGrad);
    } else {
        draw3DSphere(context, x, y, radius, bubble.color);
    }
}
function drawGrid() { for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])drawBubble(ctx,grid[r][c]);}
function drawPopAnimations() { popAnimations.forEach(p=>{ const progress = p.life / p.duration; const alpha = 1 - progress; const currentSize = p.size * (1 - progress * 0.5); if (currentSize <= 0) return; let grad = ctx.createRadialGradient(p.x - currentSize * 0.3, p.y - currentSize * 0.3, 0, p.x, p.y, currentSize); const particleColor = p.color || '#cccccc'; const darkParticleColor = darkenColor(particleColor, 0.5); grad.addColorStop(0, hexToRgba('white', alpha * 0.8)); grad.addColorStop(0.5, hexToRgba(particleColor, alpha)); grad.addColorStop(1, hexToRgba(darkParticleColor, alpha)); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2); ctx.fill(); });}
function drawFloatingPoints() { ctx.font="bold 24px 'Fredoka One',cursive";ctx.textAlign='center';ctx.textBaseline='middle';floatingPoints.forEach(fp=>{const p=fp.life/fp.duration;const alpha=1-p*p;ctx.fillStyle=`rgba(255,255,255,${alpha})`;ctx.strokeStyle=`rgba(60,60,60,${alpha*0.8})`;ctx.lineWidth=4;ctx.strokeText(fp.text,fp.x,fp.y);ctx.fillText(fp.text,fp.x,fp.y)});ctx.lineWidth=1;}
function drawAimingLine() { if(aim.y>playerBubble.y-20)return;const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x);ctx.beginPath();ctx.moveTo(playerBubble.x,playerBubble.y);ctx.lineTo(playerBubble.x+Math.cos(angle)*1e3,playerBubble.y+Math.sin(angle)*1e3);ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.setLineDash([5,10]);ctx.lineWidth=3;ctx.stroke();ctx.setLineDash([]);}
function drawGameOverLine() { ctx.beginPath();ctx.moveTo(0,GAME_OVER_LINE_Y);ctx.lineTo(canvas.width,GAME_OVER_LINE_Y);ctx.strokeStyle='rgba(255,0,0,0.7)';ctx.lineWidth=3;ctx.setLineDash([10,5]);ctx.stroke();ctx.setLineDash([]);}
function drawFireworks() { fireworks.forEach(p=>{ctx.beginPath();ctx.fillStyle=p.color;ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill()});}
function drawRain() { ctx.strokeStyle='rgba(174,194,224,0.5)'; ctx.lineWidth=2; rain.forEach(p=>{ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(p.x,p.y+p.len);ctx.stroke()}); ctx.lineWidth=1;}
function drawBombSparks() { bombSparks.forEach(s=>{ctx.fillStyle=s.color;ctx.fillRect(s.x,s.y,2,2)}); }
function drawShockwaves() { ctx.save(); shockwaves.forEach(sw => { const easeOutQuad = t => t * (2 - t); const progress = easeOutQuad(sw.life / sw.duration); const fadeProgress = sw.life / sw.duration; const currentRadius = BUBBLE_RADIUS + (BUBBLE_RADIUS * 5.5) * progress; const alpha = 1 - fadeProgress; ctx.beginPath(); ctx.arc(sw.x, sw.y, currentRadius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.7})`; ctx.lineWidth = 10 * alpha; ctx.stroke(); }); ctx.restore();}

// --- Update & Game Logic ---
function updatePopAnimations() { for(let i=popAnimations.length-1;i>=0;i--){const p=popAnimations[i];p.life++;p.x+=p.vx;p.y+=p.vy;p.vx*=0.97;p.vy*=0.97;if(p.life>=p.duration){popAnimations.splice(i,1)}}}
function updateFloatingPoints() { for(let i=floatingPoints.length-1;i>=0;i--){const fp=floatingPoints[i];fp.life++;fp.y+=fp.vy;if(fp.life>=fp.duration){floatingPoints.splice(i,1)}}}
function updateFireworks() { for(let i=fireworks.length-1;i>=0;i--){const p=fireworks[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.02;p.size*=0.98;if(p.size<0.5)fireworks.splice(i,1)} if(Math.random()<0.05)createFirework();}
function updateRain() { for(let i=rain.length-1;i>=0;i--){const p=rain[i];p.y+=p.speed;if(p.y>canvas.height){p.y=-p.len;p.x=Math.random()*canvas.width}};}
function updateBombSparks() { for(let i=bombSparks.length-1;i>=0;i--){const s=bombSparks[i];s.life++;s.x+=s.vx;s.y+=s.vy;if(s.life>=s.duration)bombSparks.splice(i,1)}}
function updateShockwaves() { for (let i = shockwaves.length - 1; i >= 0; i--) { const sw = shockwaves[i]; sw.life++; if (sw.life >= sw.duration) { shockwaves.splice(i, 1); }}}
function update() {
    updatePopAnimations(); updateFloatingPoints(); updateBombSparks(); updateShockwaves();
    rainbowGradientOffset = (rainbowGradientOffset + 0.005) % 1;
    if(isFiring){playerBubble.x+=playerBubble.vx;playerBubble.y+=playerBubble.vy;if(playerBubble.x-BUBBLE_RADIUS<0||playerBubble.x+BUBBLE_RADIUS>canvas.width)playerBubble.vx*=-1;if(playerBubble.y-BUBBLE_RADIUS<0){snapBubble(null);return}for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c]&&Math.hypot(playerBubble.x-grid[r][c].x,playerBubble.y-grid[r][c].y)<BUBBLE_RADIUS*2){snapBubble({r,c});return}}
    rowDropTimer++; 
    if(rowDropTimer >= LEVEL_ROW_DROP_SPEEDS[level]){ 
        addNewRow(); 
    }
    bombTimer++; if(bombTimer >= BOMB_INTERVAL) { spawnBombBubble(); }
}

async function snapBubble(collidedCoords) { 
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    
    isFiring=false;
    playerBubble.vx=0;playerBubble.vy=0;let s=null; 
    if(collidedCoords===null){let d=Infinity;for(let c=0;c<COLS;c++)if(!grid[0][c]){const D=Math.abs(playerBubble.x-(offsetX+c*HEX_WIDTH));if(D<d){d=D;s={r:0,c}}}} 
    else{const n=getNeighbors(collidedCoords.r,collidedCoords.c);let d=Infinity;for(const N of n)if(!grid[N.r][N.c]){const x=offsetX+N.c*HEX_WIDTH+(N.r%2)*BUBBLE_RADIUS,y=offsetY+N.r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s=N}}} 
    if(s===null){let d=Infinity;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(!grid[r][c]){const x=offsetX+c*HEX_WIDTH+(r%2)*BUBBLE_RADIUS,y=offsetY+r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s={r,c}}}} 
    if(s){grid[s.r][s.c]=createBubble(s.r,s.c,playerBubble.color,playerBubble.type);
    await handlePostSnap(s.r,s.c)}
    else{prepareNextShot()}
}

function createFloatingPoints(text, x, y) { floatingPoints.push({text,x,y,life:0,duration:FLOATING_POINTS_DURATION,vy:-0.7});}
function createPopEffect(x, y, color) { for(let i=0;i<POP_PARTICLE_COUNT;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*2+1;popAnimations.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:0,duration:POP_PARTICLE_DURATION,color:color||'#ccc',size:Math.random()*5+3});}}

async function handlePostSnap(row, col) {
    // NOTE: This function's logic is UNIVERSAL and applies to all levels.
    // The `level` variable only affects colors and speed, not this core mechanic.
    const landedBubble = grid[row][col];
    if (!landedBubble) return;

    // --- Step 1: Handle Rainbow Transformation (if applicable) ---
    if (landedBubble.type === SPECIALS.RAINBOW) {
        const neighbors = getNeighbors(row, col).map(n => grid[n.r]?.[n.c]).filter(b => b && b.type === 'normal');
        const candidateColors = new Set(neighbors.map(n => n.color));
        let bestColor = null, maxMatchSize = 0;
        for (const color of candidateColors) {
            landedBubble.color = color;
            const potentialMatches = findMatches(row, col);
            if (potentialMatches.length > maxMatchSize) {
                maxMatchSize = potentialMatches.length;
                bestColor = color;
            }
        }
        landedBubble.color = (bestColor && maxMatchSize >= 3) ? bestColor : currentColors[Math.floor(Math.random() * currentColors.length)];
        landedBubble.type = 'normal';
    }

    // --- Step 2: Find all bubbles to pop, from matches and floaters ---
    const coordsToPop = new Set();
    const floatingBubbles = [];

    // First, check for a bomb or a standard match from the landed bubble
    if (landedBubble.type === 'bomb') {
        playSound('bomb', { gain: 0.6 });
        const bombCoords = getBombAffectedCoords(row, col);
        bombCoords.forEach(coordStr => coordsToPop.add(coordStr));
        const landedBubblePos = { x: offsetX + col * HEX_WIDTH + (row % 2) * BUBBLE_RADIUS, y: offsetY + row * HEX_HEIGHT };
        createExplosionEffect(landedBubblePos.x, landedBubblePos.y);
        shockwaves.push({ x: landedBubblePos.x, y: landedBubblePos.y, life: 0, duration: 35 });
    } else {
        const matches = findMatches(row, col);
        if (matches.length >= 3) {
            matches.forEach(coord => coordsToPop.add(`${coord.r},${coord.c}`));
        }
    }
    
    // CRUCIAL FIX: Always check for floating bubbles, regardless of whether a match was made.
    const floaters = findFloatingBubbles(coordsToPop);
    if (floaters.length > 0) {
        floaters.forEach(coord => {
            coordsToPop.add(`${coord.r},${coord.c}`);
            floatingBubbles.push(coord); // Keep a separate list for drop points
        });
    }

    // --- Step 3: Process the results ---
    if (coordsToPop.size > 0) {
        let totalPoints = 0, lifeBubblesPopped = 0, dropPoints = 0;

        for (const coordStr of coordsToPop) {
            const [r, c] = coordStr.split(',').map(Number);
            const bubble = grid[r]?.[c];
            if (bubble) {
                if (floatingBubbles.some(fb => fb.r === r && fb.c === c)) {
                    dropPoints += 100;
                } else {
                    totalPoints += 50;
                }
                if (bubble.type === 'life') lifeBubblesPopped++;
                else if (bubble.type !== 'bomb') playSound('pop', { gain: 0.4 });
                createPopEffect(bubble.x, bubble.y, bubble.color);
            }
        }
        
        if (lifeBubblesPopped > 0) {
            playSound('life', { gain: 0.6 });
            shotsFired = Math.max(0, shotsFired - lifeBubblesPopped);
            createFloatingPoints(`-${lifeBubblesPopped} Miss!`, canvas.width / 2, canvas.height / 2);
        }

        score += totalPoints + dropPoints;
        if(totalPoints > 0) createFloatingPoints(`+${totalPoints}`, landedBubble.x, landedBubble.y);
        if(dropPoints > 0) createFloatingPoints(`+${dropPoints} Drop!`, canvas.width / 2, canvas.height * 0.6);
        
        for (const coordStr of coordsToPop) {
            const [r, c] = coordStr.split(',').map(Number);
            if (grid[r]) grid[r][c] = null;
        }
    } else {
        shotsFired++; // Only a miss if NO bubbles were popped.
    }

    // --- Step 4: Post-Turn & Level-Up Checks ---
    updateUI();
    if (isGridEmpty()) {
        if (level < MAX_LEVEL) {
            level++;
            updateLevelStyles(level);
            currentColors = ALL_COLORS[level];
            gameState = 'levelup';
            playSound('levelUp', { gain: 0.6 });
            levelUpMessageEl.innerText = `Board Cleared! Moving to Level ${level}!`;
            levelUpOverlay.style.display = 'flex';
        } else { endGame(true); }
        return;
    }
    if (level < MAX_LEVEL && score >= LEVEL_UP_SCORES[level]) {
        level++;
        updateLevelStyles(level);
        currentColors = ALL_COLORS[level];
        gameState = 'levelup';
        playSound('levelUp', { gain: 0.5 });
        levelUpMessageEl.innerText = `You've reached Level ${level}! Get ready for a new board with new colors!`;
        levelUpOverlay.style.display = 'flex';
        return;
    }
    for (let c = 0; c < COLS; c++) if (grid[ROWS - 1][c]) { endGame(false); return; }
    if (shotsFired >= SHOTS_UNTIL_LOSS) { endGame(false); return; }
    
    prepareNextShot();
}

function getBombAffectedCoords(row, col) {
    const affectedCoordsSet = new Set();
    affectedCoordsSet.add(`${row},${col}`);
    const firstRing = getNeighbors(row, col);
    firstRing.forEach(coord => affectedCoordsSet.add(`${coord.r},${coord.c}`));
    firstRing.forEach(neighbor => {
        getNeighbors(neighbor.r, neighbor.c).forEach(secondNeighbor => {
            affectedCoordsSet.add(`${secondNeighbor.r},${secondNeighbor.c}`);
        });
    });
    return affectedCoordsSet;
}

function createExplosionEffect(x, y) { for (let i = 0; i < 60; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 6 + 2; popAnimations.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0, duration: POP_PARTICLE_DURATION + 30, color: Math.random() < 0.7 ? 'orange' : '#FFDD00', size: Math.random() * 8 + 5 });}}

function addNewRow() {
    for (let c = 0; c < COLS; c++) {
        if (grid[ROWS - 1][c]) {
            endGame(false);
            return;
        }
    }
    newRowsDropped++;
    for (let r = ROWS - 2; r >= 0; r--) {
        for (let c = 0; c < COLS; c++) {
            grid[r + 1][c] = grid[r][c];
        }
    }
    for (let r = 1; r < ROWS; r++) { 
        for (let c = 0; c < COLS; c++) {
            const bubble = grid[r][c];
            if (bubble) {
                bubble.row = r;
                bubble.x = offsetX + c * HEX_WIDTH + (r % 2) * BUBBLE_RADIUS;
                bubble.y = offsetY + r * HEX_HEIGHT;
            }
        }
    }
    const addLifeBubble = (newRowsDropped > 0 && newRowsDropped % 2 === 0);
    let lifeCol = addLifeBubble ? Math.floor(Math.random() * COLS) : -1;
    for (let c = 0; c < COLS; c++) {
        if (c === lifeCol) {
            grid[0][c] = createBubble(0, c, '#ffffff', 'life');
        } else {
            grid[0][c] = createBubble(0, c, null, 'normal');
        }
    }
    rowDropTimer = 0;
}

function spawnBombBubble() { nextBubble = { type: 'bomb', color: '#444' }; updateUI(); bombTimer = 0; }
function prepareNextShot() {
    if(gameState!=='playing')return;
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);

    playerBubble={...nextBubble,x:canvas.width/2,y:canvas.height-BUBBLE_RADIUS};
    if(playerBubble.type === 'bomb') { sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.15 }); }
    if(playerBubble.type === 'rainbow') { rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.2 }); }

    nextBubble=generateNextBubble();
    updateUI();
}
function getNeighbors(r,c) { const p=r%2,d=[{dr:0,dc:1},{dr:0,dc:-1},{dr:-1,dc:p-1},{dr:-1,dc:p},{dr:1,dc:p-1},{dr:1,dc:p}],n=[];for(const i of d){const nr=r+i.dr,nc=c+i.dc;if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS)n.push({r:nr,c:nc})}return n}

function findMatches(startR, startC) {
    const startBubble = grid[startR]?.[startC];
    if (!startBubble || startBubble.type === 'life' || startBubble.type === 'bomb') {
        return [];
    }

    const matchColor = startBubble.color;
    const cluster = [];
    const toVisit = [{ r: startR, c: startC }];
    const visited = new Set([`${startR},${startC}`]);

    while (toVisit.length > 0) {
        const currentCoord = toVisit.shift();
        cluster.push(currentCoord);

        for (const neighborCoord of getNeighbors(currentCoord.r, currentCoord.c)) {
            const coordStr = `${neighborCoord.r},${neighborCoord.c}`;
            if (!visited.has(coordStr)) {
                const neighborBubble = grid[neighborCoord.r]?.[neighborCoord.c];
                if (neighborBubble) {
                    if (neighborBubble.color === matchColor || neighborBubble.type === 'life') {
                        visited.add(coordStr);
                        toVisit.push(neighborCoord);
                    }
                }
            }
        }
    }

    const colorBubbleCount = cluster.reduce((count, coord) => {
        return grid[coord.r][coord.c]?.type === 'normal' ? count + 1 : count;
    }, 0);
    
    if (cluster.length >= 3 && colorBubbleCount > 0) {
        return cluster;
    }

    return [];
}

function findFloatingBubbles(coordsToIgnore = new Set()) {
    const anchored = new Set();
    const queue = [];

    // Start traversal from top-row bubbles that are not being popped
    for (let c = 0; c < COLS; c++) {
        const coordStr = `0,${c}`;
        if (grid[0][c] && !coordsToIgnore.has(coordStr)) {
            queue.push({ r: 0, c: c });
            anchored.add(coordStr);
        }
    }

    // BFS to find all anchored bubbles
    let head = 0;
    while (head < queue.length) {
        const current = queue[head++];
        for (const neighbor of getNeighbors(current.r, current.c)) {
            const neighborStr = `${neighbor.r},${neighbor.c}`;
            if (grid[neighbor.r][neighbor.c] && !anchored.has(neighborStr) && !coordsToIgnore.has(neighborStr)) {
                anchored.add(neighborStr);
                queue.push(neighbor);
            }
        }
    }

    // Any bubble not in the anchored set (and not being popped) is floating
    const floating = [];
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const coordStr = `${r},${c}`;
            if (grid[r][c] && !anchored.has(coordStr) && !coordsToIgnore.has(coordStr)) {
                floating.push({ r, c });
            }
        }
    }
    return floating;
}

function isGridEmpty() { for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])return false; return true;}

function endGame(isWinner) {
    gameState='gameover';
    isFiring=false;
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    
    let message = '';
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('bubblePopHighScore', highScore);
        message = isWinner ? 'You Win! New High Score!' : 'New High Score!';
    } else {
        message = isWinner ? 'You Win!' : 'Sorry, you lost!';
    }
    endMessageEl.innerText = message;

    if(isWinner){
        playSound('win', { gain: 0.5 });
        createFirework();
    } else {
        playSound('lose', { gain: 0.5 });
        createRain();
    }
    finalScoreEl.innerText = score;
    gameOverEl.style.display='flex';
}

function createFirework() { const x=Math.random()*canvas.width*0.8+canvas.width*0.1; const y=Math.random()*canvas.height*0.5+canvas.height*0.1; const color=`hsl(${Math.random()*360},100%,50%)`; for(let i=0;i<50;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*3+1;fireworks.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,color,size:Math.random()*2+1})}}
function createRain() { for(let i=0;i<100;i++){rain.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,len:Math.random()*20+10,speed:Math.random()*5+2})}}

function handleAimUpdate(clientX,clientY) {
    if(gameState!=='playing')return;
    const rect=canvas.getBoundingClientRect();
    aim.x=(clientX-rect.left)*(canvas.width/rect.width);
    aim.y=(clientY-rect.top)*(canvas.height/rect.height);
    const currentAngle = Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x);
    if (Math.abs(currentAngle - lastAimAngle) > 0.03) {
        aimClickCounter++;
        if (aimClickCounter % 3 === 0) {
            playSound('shick', { gain: 0.7 });
        }
        lastAimAngle = currentAngle;
    }
}

function handleFire() {
    if(gameState!=='playing'||isFiring||aim.y>playerBubble.y-20)return;
    playSound('shoot', { gain: 0.25 });

    const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x),speed=15;
    playerBubble.vx=Math.cos(angle)*speed;
    playerBubble.vy=Math.sin(angle)*speed;
    isFiring=true;
}

// --- Event Listeners ---
document.getElementById('continue-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});rulesOverlay.style.display='none';startOverlay.style.display='flex'});
document.getElementById('play-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});startOverlay.style.display='none';gameState='playing'});
document.getElementById('play-again-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});gameOverEl.style.display='none';init();startOverlay.style.display='flex'});
document.getElementById('restart-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});if(gameState==='playing'&&confirm('Are you sure you want to restart the game?')){init();startOverlay.style.display='flex'}else if(gameState!=='playing'){init();startOverlay.style.display='flex'}});
document.getElementById('level-up-continue-button').addEventListener('click', () => {
    initAudio(); playSound('click',{gain:0.4});
    levelUpOverlay.style.display = 'none';
    resetForNextLevel();
    gameState = 'playing';
});
audioToggleButton.addEventListener('click', () => {
    isMuted = !isMuted;
    audioToggleButton.innerText = isMuted ? "Sound: OFF" : "Sound: ON";
    if (isMuted) {
        sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
        rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    } else {
        initAudio();
        playSound('click', {gain: 0.4});
        if (playerBubble && playerBubble.type === 'bomb') sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.15 });
        if (playerBubble && playerBubble.type === 'rainbow') { rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.2 }); }
    }
});

if(isMobile){canvas.addEventListener('touchmove',e=>{e.preventDefault();handleAimUpdate(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});canvas.addEventListener('touchend',e=>{e.preventDefault();handleFire()},{passive:false})}else{canvas.addEventListener('mousemove',e=>{handleAimUpdate(e.clientX,e.clientY)});canvas.addEventListener('click',handleFire)}

// --- Background Animation ---
function initBackground() { bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; backgroundBubbles = []; let bubbleCount = 30; for (let i = 0; i < bubbleCount; i++) { backgroundBubbles.push({ x: Math.random() * bgCanvas.width, y: Math.random() * bgCanvas.height, radius: Math.random() * 25 + 10, speed: Math.random() * 1 + 0.5, opacity: Math.random() * 0.3 + 0.1 });}}
function updateBackgroundBubbles() { for (let i = 0; i < backgroundBubbles.length; i++) { const b = backgroundBubbles[i]; b.y -= b.speed; if (b.y < -b.radius) { b.y = bgCanvas.height + b.radius; b.x = Math.random() * bgCanvas.width; b.speed = Math.random() * 1 + 0.5; b.radius = Math.random() * 25 + 10; }}}
function drawBackgroundBubbles() { bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height); for (let i = 0; i < backgroundBubbles.length; i++) { const b = backgroundBubbles[i]; let grad = bgCtx.createRadialGradient( b.x - b.radius * 0.3, b.y - b.radius * 0.3, 0, b.x, b.y, b.radius ); grad.addColorStop(0, `rgba(255, 255, 255, ${b.opacity + 0.2})`); grad.addColorStop(1, `rgba(174, 222, 252, ${b.opacity})`); bgCtx.fillStyle = grad; bgCtx.beginPath(); bgCtx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); bgCtx.fill();}}
window.addEventListener('resize', initBackground);

// --- Main Game Loop ---
function gameLoop() {
    updateBackgroundBubbles(); drawBackgroundBubbles();
    if (gameState === 'playing') update();
    if (gameState === 'gameover') { if (fireworks.length > 0) updateFireworks(); if (rain.length > 0) updateRain(); }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    if(gameState==='playing')drawBubble(ctx,playerBubble);
    if(gameState==='playing'&&!isFiring)drawAimingLine();
    drawPopAnimations(); drawFloatingPoints(); drawBombSparks(); drawShockwaves(); drawGameOverLine();
    if(gameState === 'gameover') { drawFireworks(); drawRain(); }
    requestAnimationFrame(gameLoop);
}

// --- Start Game ---
initBackground(); init(); gameLoop();
</script>
</body>
</html>
