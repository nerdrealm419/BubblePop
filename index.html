<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pop! Pop! Bubble Stop! - Level Up!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html {
            height: 100%;
        }
        body {
            background: radial-gradient(circle, #5c97bf, #1c3d5a);
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden; /* Hide scrollbars caused by background bubbles */
        }
        
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* This is crucial to place it behind everything */
        }

        h1 {
            margin-bottom: 10px;
            font-family: 'Fredoka One', cursive;
            font-size: 2.5em;
            color: white;
            text-shadow: 2px 2px 4px #4a2d6b;
            position: relative; 
            z-index: 2;
            text-align: center;
        }

        #game-container {
            position: relative;
            width: 500px;
            height: 600px;
            max-width: 90vw; /* Ensure it doesn't get too wide on large screens */
            max-height: 80vh; /* Ensure it fits vertically */
            background-color: rgba(214, 232, 250, 0.65); /* Semi-transparent */
            backdrop-filter: blur(4px); /* Frosted glass effect */
            border: 5px solid rgba(163, 193, 227, 0.7); /* Semi-transparent border */
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            border-radius: 10px;
            z-index: 1;
        }

        canvas {
            display: block;
            background-color: transparent;
            width: 100%;
            height: 100%;
        }
        
        #ui-container {
            width: 95%;
            max-width: 500px;
            margin-top: 15px;
            padding: 10px;
            box-sizing: border-box;
            background-color: rgba(214, 232, 250, 0.65); /* Semi-transparent */
            backdrop-filter: blur(4px); /* Frosted glass effect */
            border: 5px solid rgba(163, 193, 227, 0.7); /* Semi-transparent border */
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on medium screens */
            gap: 10px;
            color: #4a2d6b;
            font-size: 18px;
            font-weight: bold;
            z-index: 1;
        }

        #restart-button, #audio-toggle-button {
            padding: 5px 10px; font-size: 14px; font-weight: bold; cursor: pointer;
            border: 2px solid #4a2d6b; background-color: white; color: #4a2d6b; border-radius: 5px;
        }
        .next-bubble-area {
            display: flex; align-items: center; gap: 8px;
        }

        .overlay-screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            color: white;
            display: flex; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.5em;
            border-radius: 5px; /* Match inner radius of container */
            z-index: 10; /* Ensure overlays are on top */
        }
        .overlay-screen h2 {
            font-family: 'Fredoka One', cursive; margin-top: 0; margin-bottom: 20px;
            font-size: 1.8em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .overlay-screen button {
            margin-top: 20px; padding: 15px 30px;
            font-size: 1em; font-weight: bold; font-family: 'Fredoka One', cursive;
            cursor: pointer; border: 2px solid white; background-color: #8c6ba9;
            color: white; border-radius: 10px; transition: transform 0.1s ease;
        }
        .overlay-screen button:hover { transform: scale(1.05); }

        #rules-overlay ul { list-style: none; padding: 0; margin: 0; font-size: 0.7em; max-width: 80%;}
        #rules-overlay li { margin-bottom: 15px; }
        #game-over { display: none; }
        #start-overlay { display: none; }
        #level-up-overlay { display: none; }
        #level-up-overlay p { font-size: 0.8em; margin: 10px 0 20px 0; }


        /* Responsive UI for Mobile */
        @media (max-width: 480px) {
            h1 {
                font-size: 2em;
            }
            #ui-container {
                justify-content: center; /* Center items for a better look when wrapped */
            }
            #restart-button, #audio-toggle-button {
                padding: 10px 15px; /* Bigger button for easier tapping */
            }
        }

    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>

    <h1>Pop! Pop! Bubble Stop!</h1>
    <div id="game-container">
        <canvas id="gameCanvas" width="500" height="600"></canvas>
        <div id="rules-overlay" class="overlay-screen">
            <h2>How to Play</h2>
            <ul>
                <li>Match 3+ bubbles to score.</li>
                <li>Clear all bubbles to win a huge bonus!</li>
                <li>Level up by reaching score milestones!</li>
                <li>A powerful Bomb Bubble may appear to clear a large area!</li>
                <li>An extra life bubble may appear. Pop it to remove a miss!</li>
                <li>5 misses and you lose!</li>
            </ul>
            <button id="continue-button">Continue</button>
        </div>
        <div id="level-up-overlay" class="overlay-screen">
            <h2 id="level-up-title">Level Up!</h2>
            <p id="level-up-message">Congratulations! Get ready for the next challenge.</p>
            <button id="level-up-continue-button">Continue</button>
        </div>
        <div id="start-overlay" class="overlay-screen"> <button id="play-button">Play!</button> </div>
        <div id="game-over" class="overlay-screen">
            <h2 id="end-message">Game Over</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="play-again-button">Play Again</button>
        </div>
    </div>
    
    <div id="ui-container">
        <div>Level: <span id="level">1</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Misses: <span id="miss-counter">0</span>/5</div>
        <div class="next-bubble-area">
            <span>Next:</span>
            <canvas id="nextBubbleCanvas" width="40" height="40"></canvas>
        </div>
        <button id="audio-toggle-button">Sound: ON</button>
        <button id="restart-button">Restart</button>
    </div>

<script>
// --- Game Setup & Constants ---
const bgCanvas = document.getElementById('backgroundCanvas'), bgCtx = bgCanvas.getContext('2d');
const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
const nextBubbleCanvas = document.getElementById('nextBubbleCanvas'), nextCtx = nextBubbleCanvas.getContext('2d');
const scoreEl = document.getElementById('score'), levelEl = document.getElementById('level'), gameOverEl = document.getElementById('game-over');
const missCounterEl = document.getElementById('miss-counter');
const finalScoreEl = document.getElementById('finalScore'), rulesOverlay = document.getElementById('rules-overlay');
const startOverlay = document.getElementById('start-overlay'), endMessageEl = document.getElementById('end-message');
const levelUpOverlay = document.getElementById('level-up-overlay'), levelUpMessageEl = document.getElementById('level-up-message');
const audioToggleButton = document.getElementById('audio-toggle-button');

const COLS = 12, ROWS = 14, SHOTS_UNTIL_LOSS = 5;
const TIME_UNTIL_ROW_DROP = 20 * 60, BOMB_INTERVAL = 25 * 60;
const FLOATING_POINTS_DURATION = 75, POP_PARTICLE_COUNT = 8, POP_PARTICLE_DURATION = 40;
const PADDING = 5, BUBBLE_RADIUS = (canvas.width - PADDING * 2) / (COLS * 2);
const HEX_WIDTH = BUBBLE_RADIUS * 2, HEX_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS;
const offsetX = PADDING + BUBBLE_RADIUS, offsetY = PADDING + BUBBLE_RADIUS;
const GAME_OVER_LINE_Y = canvas.height - BUBBLE_RADIUS * 4;

const ALL_COLORS = {
    1: ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF', '#FFFF33'],
    2: ['#b1e5f2', '#f7c5d8', '#c8e6c9', '#fff9c4', '#d1c4e9', '#ffccbc'],
    3: ['#c0c0c0', '#ffd700', '#b87333', '#738b9c', '#8a7f8d', '#987f69']
};
const LEVEL_UP_SCORES = { 1: 5000, 2: 10000 };
const SPECIALS = { 'RAINBOW': 'rainbow', 'LIFE': 'life', 'BOMB': 'bomb' };
const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);

// --- Audio Engine ---
let audioContext;
const sounds = {};
let lastAimAngle = 0;
let audioInitialized = false;
let isMuted = false;
let sizzleSoundSource = null, rainbowSoundSource = null;
let aimClickCounter = 0;

async function initAudio() {
    if (audioInitialized || audioContext) return;
    audioInitialized = true;
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') { await audioContext.resume(); }
        await createAllSounds();
    } catch (e) { console.error("Web Audio API failed to initialize.", e); }
}

function playSound(name, options = {}) {
    if (isMuted || !audioContext || !sounds[name]) return;
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(options.gain !== undefined ? options.gain : 0.5, audioContext.currentTime);
    source.connect(gainNode).connect(audioContext.destination);
    source.start(0);
}

function playLoopingSound(name, options = {}) {
    if (isMuted || !audioContext || !sounds[name]) return null;
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    source.loop = true;
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(options.gain !== undefined ? options.gain : 0.4, audioContext.currentTime);
    source.connect(gainNode).connect(audioContext.destination);
    source.start(0);
    return source;
}

function stopLoopingSound(source) {
    if (source) {
        source.stop();
    }
    return null;
}

const soundGenerators = {
    click: async actx => { const d=0.05,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=Math.sin(6.28*2e3*p)*Math.pow(1-p,4)}return b;},
    shick: async actx => { const d=0.08,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++)c[i]=(Math.random()*2-1)*Math.pow(1-i/c.length,10);const o=new OfflineAudioContext(1,actx.sampleRate*d,actx.sampleRate),s=o.createBufferSource();s.buffer=b;const h=o.createBiquadFilter();h.type='highpass';h.frequency.value=1500;const p=o.createBiquadFilter();p.type='bandpass';p.frequency.value=4e3;p.Q.value=1.5;s.connect(h).connect(p).connect(o.destination);s.start();return await o.startRendering();},
    shoot: async actx => { const d=0.2,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=(Math.random()*2-1)*Math.pow(1-p,2)*.3+Math.sin(6.28*(2e3-p*1800)*p)*Math.pow(1-p,2)*.7}return b;},
    pop: async actx => { const d=0.1,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=Math.sin(6.28*(600-p*400)*p)*Math.pow(1-p,2)}return b;},
    bomb: async actx => { const d=0.8,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=(Math.random()*2-1)*Math.pow(1-p,4)+Math.sin(6.28*100*Math.pow(1-p,2)*p)*Math.pow(1-p,2)}return b;},
    life: async actx => { const d=0.3,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0),n1=Math.floor(actx.sampleRate*.1),n2=Math.floor(actx.sampleRate*.12);for(let i=0;i<n1;i++){const p=i/n1;c[i]=Math.sin(6.28*523.25*(i/actx.sampleRate))*Math.pow(1-p,2)*.8}for(let i=n2;i<c.length;i++){const p=(i-n2)/(c.length-n2);c[i]+=Math.sin(6.28*783.99*((i-n2)/actx.sampleRate))*Math.pow(1-p,2)*.8}return b;},
    levelUp: async actx => { const d=.1,n=[261.63,329.63,392,523.25],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,1.5)}}return b;},
    win: async actx => { const d=.12,n=[523.25,659.25,783.99,1046.5,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*(d*n.length+.2),actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*(1-p)*.8}}return b;},
    lose: async actx => { const d=.25,n=[440,349.23,261.63,196],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,.5)*.7}}return b;},
    sizzle: async actx => { const d=1,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){c[i]=(Math.random()*2-1)*.4}const f=actx.createBiquadFilter();f.type='bandpass';f.frequency.value=2e3;f.Q.value=.5;const s=actx.createBufferSource();s.buffer=b;s.connect(f);const dest=actx.createMediaStreamDestination();f.connect(dest);return b;},
    rainbow: async actx => { const d=.15,n=[523.25,659.25,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,2)*.8}}return b;},
};

async function createAllSounds() {
    const promises = Object.keys(soundGenerators).map(async name => {
        sounds[name] = await soundGenerators[name](audioContext);
    });
    await Promise.all(promises);
}

// --- Game State ---
let grid, playerBubble, nextBubble, score, shotsFired, rowDropTimer, bombTimer, newRowsAdded;
let isFiring = false, aim = { x: canvas.width / 2, y: 0 };
let popAnimations = [], floatingPoints = [], fireworks = [], rain = [], bombSparks = [], shockwaves = [];
let gameState = 'rules';
let backgroundBubbles = [];
let level, currentColors, rainbowGradientOffset;

function hexToRgba(hex, alpha) { if(!hex) return `rgba(0,0,0,${alpha})`; const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return r?`rgba(${parseInt(r[1],16)},${parseInt(r[2],16)},${parseInt(r[3],16)},${alpha})`:`rgba(0,0,0,${alpha})`;}
function darkenColor(hex, percent) { if (!hex) return '#000000'; let f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF; return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);}
function createBubble(row, col, color=null, type='normal') { if(color===null)color=currentColors[Math.floor(Math.random()*currentColors.length)]; const x = offsetX + col*HEX_WIDTH + (row%2)*BUBBLE_RADIUS; const y = offsetY + row*HEX_HEIGHT; return {row,col,x,y,color,type,vx:0,vy:0};}
function generateNextBubble() { let color = currentColors[Math.floor(Math.random()*currentColors.length)], type='normal'; if(Math.random()<0.05){type=SPECIALS.RAINBOW;color=null} return {x:canvas.width/2,y:canvas.height-BUBBLE_RADIUS,color,type,vx:0,vy:0};}

function resetForNextLevel() {
    grid = Array(ROWS).fill(null).map(()=>Array(COLS).fill(null));
    isFiring = false;
    rowDropTimer=0; bombTimer=0; newRowsAdded = 0; aimClickCounter = 0;
    popAnimations=[]; floatingPoints=[]; fireworks=[]; rain=[]; bombSparks=[]; shockwaves=[];
    
    for (let r=0;r<4;r++) {
        for (let c=0;c<COLS;c++) {
            if (!((r%2===1)&&c===COLS-1)) grid[r][c]=createBubble(r, c);
        }
    }
    grid[0][0] = createBubble(0, 0, '#ffffff', 'life');
    grid[0][COLS - 1] = createBubble(0, COLS - 1, '#ffffff', 'life');
    
    playerBubble=generateNextBubble(); nextBubble=generateNextBubble(); 
    updateUI();
}

function init() {
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    score=0; shotsFired=0;
    level = 1;
    currentColors = ALL_COLORS[level];
    rainbowGradientOffset = 0;
    resetForNextLevel();
    gameState = 'pregame';
    updateUI();
}

function updateUI() { 
    scoreEl.innerText=score; 
    levelEl.innerText = level;
    missCounterEl.innerText = shotsFired; 
    nextCtx.clearRect(0,0,nextBubbleCanvas.width,nextBubbleCanvas.height); 
    drawBubble(nextCtx,{...nextBubble,x:nextBubbleCanvas.width/2,y:nextBubbleCanvas.height/2,radius:BUBBLE_RADIUS*0.8});
}

// --- Drawing Functions ---
function draw3DSphere(context, x, y, radius, baseStyle) {
    if (typeof baseStyle === 'string') { context.fillStyle = hexToRgba(baseStyle, 0.75); } else { context.fillStyle = baseStyle; }
    context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let glowGrad = context.createRadialGradient(x, y, 0, x, y, radius);
    glowGrad.addColorStop(0, 'rgba(255, 255, 255, 0.2)'); glowGrad.addColorStop(0.8, 'rgba(255, 255, 255, 0)');
    context.fillStyle = glowGrad; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let shadowGrad = context.createRadialGradient(x + radius * 0.4, y + radius * 0.5, radius * 0.5, x, y, radius * 1.5);
    shadowGrad.addColorStop(0, 'rgba(0,0,0,0.3)'); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = shadowGrad; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let highlightGrad = context.createRadialGradient(x - radius * 0.4, y - radius * 0.5, 0, x - radius * 0.4, y - radius * 0.5, radius * 0.6);
    highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)'); highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    context.fillStyle = highlightGrad; context.beginPath(); context.arc(x - radius * 0.4, y - radius * 0.5, radius * 0.6, 0, Math.PI * 2); context.fill();
}
function drawBubble(context, bubble) {
    if (!bubble) return;
    const radius = bubble.radius || BUBBLE_RADIUS, x = bubble.x, y = bubble.y;
    if (bubble.type === 'life') {
        draw3DSphere(context, x, y, radius, '#FFFFFF');
        context.strokeStyle = '#D00000'; context.lineWidth = 4; const plusSize = radius * 0.5; context.beginPath();
        context.moveTo(x, y - plusSize); context.lineTo(x, y + plusSize);
        context.moveTo(x - plusSize, y); context.lineTo(x + plusSize, y);
        context.stroke(); context.lineWidth = 1; return;
    }
    if (bubble.type === 'bomb') {
        draw3DSphere(context, x, y, radius, '#333333');
        context.fillStyle = '#999'; context.fillRect(x - radius*0.15, y - radius*0.8, radius*0.3, radius*0.3);
        if(Math.random() < 0.5) { bombSparks.push({ x: x, y: y - radius * 0.8, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2 - 1, life: 0, duration: 20, color: Math.random() < 0.5 ? 'yellow' : 'orange' }); }
        return;
    }
    if (bubble.type === 'rainbow') {
        let rainbowGrad = context.createLinearGradient(x - radius, y - radius, x + radius, y + radius);
        const colors = currentColors;
        const numColors = colors.length;
        for (let i = 0; i <= numColors * 2; i++) {
            const colorIndex = i % numColors;
            let position = (i / numColors + rainbowGradientOffset) % 1;
            rainbowGrad.addColorStop(position, colors[colorIndex]);
        }
        draw3DSphere(context, x, y, radius, rainbowGrad);
    } else {
        draw3DSphere(context, x, y, radius, bubble.color);
    }
}
function drawGrid() { for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])drawBubble(ctx,grid[r][c]);}
function drawPopAnimations() { popAnimations.forEach(p=>{ const progress = p.life / p.duration; const alpha = 1 - progress; const currentSize = p.size * (1 - progress * 0.5); if (currentSize <= 0) return; let grad = ctx.createRadialGradient(p.x - currentSize * 0.3, p.y - currentSize * 0.3, 0, p.x, p.y, currentSize); const particleColor = p.color || '#cccccc'; const darkParticleColor = darkenColor(particleColor, 0.5); grad.addColorStop(0, hexToRgba('white', alpha * 0.8)); grad.addColorStop(0.5, hexToRgba(particleColor, alpha)); grad.addColorStop(1, hexToRgba(darkParticleColor, alpha)); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2); ctx.fill(); });}
function drawFloatingPoints() { ctx.font="bold 24px 'Fredoka One',cursive";ctx.textAlign='center';ctx.textBaseline='middle';floatingPoints.forEach(fp=>{const p=fp.life/fp.duration;const alpha=1-p*p;ctx.fillStyle=`rgba(255,255,255,${alpha})`;ctx.strokeStyle=`rgba(60,60,60,${alpha*0.8})`;ctx.lineWidth=4;ctx.strokeText(fp.text,fp.x,fp.y);ctx.fillText(fp.text,fp.x,fp.y)});ctx.lineWidth=1;}
function drawAimingLine() { if(aim.y>playerBubble.y-20)return;const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x);ctx.beginPath();ctx.moveTo(playerBubble.x,playerBubble.y);ctx.lineTo(playerBubble.x+Math.cos(angle)*1e3,playerBubble.y+Math.sin(angle)*1e3);ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.setLineDash([5,10]);ctx.lineWidth=3;ctx.stroke();ctx.setLineDash([]);}
function drawGameOverLine() { ctx.beginPath();ctx.moveTo(0,GAME_OVER_LINE_Y);ctx.lineTo(canvas.width,GAME_OVER_LINE_Y);ctx.strokeStyle='rgba(255,0,0,0.7)';ctx.lineWidth=3;ctx.setLineDash([10,5]);ctx.stroke();ctx.setLineDash([]);}
function drawFireworks() { fireworks.forEach(p=>{ctx.beginPath();ctx.fillStyle=p.color;ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill()});}
function drawRain() { ctx.strokeStyle='rgba(174,194,224,0.5)'; ctx.lineWidth=2; rain.forEach(p=>{ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(p.x,p.y+p.len);ctx.stroke()}); ctx.lineWidth=1;}
function drawBombSparks() { bombSparks.forEach(s=>{ctx.fillStyle=s.color;ctx.fillRect(s.x,s.y,2,2)}); }
function drawShockwaves() { ctx.save(); shockwaves.forEach(sw => { const easeOutQuad = t => t * (2 - t); const progress = easeOutQuad(sw.life / sw.duration); const fadeProgress = sw.life / sw.duration; const currentRadius = BUBBLE_RADIUS + (BUBBLE_RADIUS * 4) * progress; const alpha = 1 - fadeProgress; ctx.beginPath(); ctx.arc(sw.x, sw.y, currentRadius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.7})`; ctx.lineWidth = 10 * alpha; ctx.stroke(); }); ctx.restore();}

// --- Update & Game Logic ---
function updatePopAnimations() { for(let i=popAnimations.length-1;i>=0;i--){const p=popAnimations[i];p.life++;p.x+=p.vx;p.y+=p.vy;p.vx*=0.97;p.vy*=0.97;if(p.life>=p.duration){popAnimations.splice(i,1)}}}
function updateFloatingPoints() { for(let i=floatingPoints.length-1;i>=0;i--){const fp=floatingPoints[i];fp.life++;fp.y+=fp.vy;if(fp.life>=p.duration){floatingPoints.splice(i,1)}}}
function updateFireworks() { for(let i=fireworks.length-1;i>=0;i--){const p=fireworks[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.02;p.size*=0.98;if(p.size<0.5)fireworks.splice(i,1)} if(Math.random()<0.05)createFirework();}
function updateRain() { for(let i=rain.length-1;i>=0;i--){const p=rain[i];p.y+=p.speed;if(p.y>canvas.height){p.y=-p.len;p.x=Math.random()*canvas.width}};}
function updateBombSparks() { for(let i=bombSparks.length-1;i>=0;i--){const s=bombSparks[i];s.life++;s.x+=s.vx;s.y+=s.vy;if(s.life>=s.duration)bombSparks.splice(i,1)}}
function updateShockwaves() { for (let i = shockwaves.length - 1; i >= 0; i--) { const sw = shockwaves[i]; sw.life++; if (sw.life >= sw.duration) { shockwaves.splice(i, 1); }}}
function update() {
    updatePopAnimations(); updateFloatingPoints(); updateBombSparks(); updateShockwaves();
    rainbowGradientOffset = (rainbowGradientOffset + 0.005) % 1;
    if(isFiring){playerBubble.x+=playerBubble.vx;playerBubble.y+=playerBubble.vy;if(playerBubble.x-BUBBLE_RADIUS<0||playerBubble.x+BUBBLE_RADIUS>canvas.width)playerBubble.vx*=-1;if(playerBubble.y-BUBBLE_RADIUS<0){snapBubble(null);return}for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c]&&Math.hypot(playerBubble.x-grid[r][c].x,playerBubble.y-grid[r][c].y)<BUBBLE_RADIUS*2){snapBubble({r,c});return}}
    rowDropTimer++; if(rowDropTimer >= TIME_UNTIL_ROW_DROP){ addNewRow(); }
    bombTimer++; if(bombTimer >= BOMB_INTERVAL) { spawnBombBubble(); }
}
async function snapBubble(collidedCoords) { isFiring=false;playerBubble.vx=0;playerBubble.vy=0;let s=null; if(collidedCoords===null){let d=Infinity;for(let c=0;c<COLS;c++)if(!grid[0][c]){const D=Math.abs(playerBubble.x-(offsetX+c*HEX_WIDTH));if(D<d){d=D;s={r:0,c}}}} else{const n=getNeighbors(collidedCoords.r,collidedCoords.c);let d=Infinity;for(const N of n)if(!grid[N.r][N.c]){const x=offsetX+N.c*HEX_WIDTH+(N.r%2)*BUBBLE_RADIUS,y=offsetY+N.r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s=N}}} if(s===null){let d=Infinity;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(!grid[r][c]&&!(r%2===1&&c===COLS-1)){const x=offsetX+c*HEX_WIDTH+(r%2)*BUBBLE_RADIUS,y=offsetY+r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s={r,c}}}} if(s){grid[s.r][s.c]=createBubble(s.r,s.c,playerBubble.color,playerBubble.type);await handlePostSnap(s.r,s.c)}else{prepareNextShot()}}
function createFloatingPoints(text, x, y) { floatingPoints.push({text,x,y,life:0,duration:FLOATING_POINTS_DURATION,vy:-0.7});}
function createPopEffect(x, y, color) { for(let i=0;i<POP_PARTICLE_COUNT;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*2+1;popAnimations.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:0,duration:POP_PARTICLE_DURATION,color:color||'#ccc',size:Math.random()*5+3});}}
function popBubbles(bubblesToPop) { bubblesToPop.forEach(b=>{if(grid[b.r]?.[b.c]){const bubble=grid[b.r][b.c];createPopEffect(bubble.x,bubble.y,bubble.color);grid[b.r][b.c]=null}});}
function dropBubbles(bubblesToDrop) { popBubbles(bubblesToDrop); }

async function handlePostSnap(row, col) { 
    let popsOccurred = false;
    const landedBubble = grid[row][col]; 

    if (landedBubble && landedBubble.type === SPECIALS.RAINBOW) {
        const neighbors = getNeighbors(row, col).map(n => grid[n.r]?.[n.c]).filter(b => b && b.type === 'normal');
        if (neighbors.length > 0) {
            const colorCounts = {};
            neighbors.forEach(n => { colorCounts[n.color] = (colorCounts[n.color] || 0) + 1; });
            landedBubble.color = Object.keys(colorCounts).reduce((a, b) => colorCounts[a] > colorCounts[b] ? a : b);
        } else {
            landedBubble.color = currentColors[Math.floor(Math.random() * currentColors.length)];
        }
        landedBubble.type = 'normal';
    }

    if (landedBubble && landedBubble.type === 'bomb') {
        popsOccurred = handleBombExplosion(row, col);
    } else {
        const matches = findMatches(row, col);
        if (matches.length >= 3) {
            popsOccurred = true;
            const points = matches.length * 10;
            score += points;
            
            let lifeBubblePopped = false;
            matches.forEach(coord => {
                const bubble = grid[coord.r]?.[coord.c];
                if (bubble) {
                    if (bubble.type === 'life') lifeBubblePopped = true;
                    else playSound('pop', { gain: 0.5 });
                }
            });

            if (lifeBubblePopped) {
                playSound('life', { gain: 0.6 });
                shotsFired = Math.max(0, shotsFired - 1);
                createFloatingPoints('-1 Miss!', canvas.width / 2, canvas.height / 2);
            }
            
            if(grid[row]?.[col]) createFloatingPoints(`+${points}`, grid[row][col].x, grid[row][col].y);
            popBubbles(matches);
        }
    }
    
    const floating = await findFloatingBubbles();
    if (floating.length > 0) {
        popsOccurred = true;
        const points = floating.length * 20;
        score += points;

        let lifeBubbleDropped = false;
        floating.forEach(coord => {
            const bubble = grid[coord.r]?.[coord.c];
            if (bubble) {
                if (bubble.type === 'life') lifeBubbleDropped = true;
                else playSound('pop', { gain: 0.4 });
            }
        });
        if (lifeBubbleDropped) {
             playSound('life', { gain: 0.6 });
             shotsFired = Math.max(0, shotsFired - 1);
             createFloatingPoints('-1 Miss!', canvas.width / 2, canvas.height / 2);
        }
        
        let centerX=0,centerY=0,bubbleCount=0;
        floating.forEach(coord => {const bubbleData=grid[coord.r]?.[coord.c];if(bubbleData){centerX+=bubbleData.x;centerY+=bubbleData.y;bubbleCount++;}});
        if(bubbleCount>0) createFloatingPoints(`+${points}`, centerX/bubbleCount, centerY/bubbleCount);
        dropBubbles(floating);
    } 
    
    if(!popsOccurred) { shotsFired++;} 
    updateUI(); 

    if (level < 3 && score >= LEVEL_UP_SCORES[level]) {
        level++;
        gameState = 'levelup';
        playSound('levelUp', { gain: 0.5 });
        currentColors = ALL_COLORS[level];
        levelUpMessageEl.innerText = `You've reached Level ${level}! Get ready for a new board with new colors!`;
        levelUpOverlay.style.display = 'flex';
        return;
    }
    
    if(isGridEmpty()){ endGame(true); return; }
    for (let c=0; c<COLS; c++) if (grid[ROWS-1][c]){ endGame(false); return; }
    if (shotsFired >= SHOTS_UNTIL_LOSS) { endGame(false); return;} 
    prepareNextShot();
}

function handleBombExplosion(row, col) {
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    playSound('bomb', { gain: 0.6 });
    let affectedCoords = [{r: row, c: col}, ...getNeighbors(row, col)];
    let points = 0;
    let bubblesPopped = 0;
    let lifeBubbleInBlast = false;

    affectedCoords.forEach(coord => { if(grid[coord.r]?.[coord.c]?.type === 'life') lifeBubbleInBlast = true; });
    if(lifeBubbleInBlast) {
        playSound('life', { gain: 0.6 });
        shotsFired = Math.max(0, shotsFired - 1);
        createFloatingPoints('-1 Miss!', canvas.width / 2, canvas.height / 2);
    }

    affectedCoords.forEach(coord => {
        if(grid[coord.r]?.[coord.c]) {
            points += 10;
            bubblesPopped++;
            const bubble = grid[coord.r][coord.c];
            createPopEffect(bubble.x, bubble.y, bubble.color);
            grid[coord.r][coord.c] = null;
        }
    });

    score += points;
    const landedBubblePos = { x: offsetX + col * HEX_WIDTH + (row % 2) * BUBBLE_RADIUS, y: offsetY + row * HEX_HEIGHT };
    if(bubblesPopped > 0) createFloatingPoints(`+${points}`, landedBubblePos.x, landedBubblePos.y);
    createExplosionEffect(landedBubblePos.x, landedBubblePos.y);
    shockwaves.push({ x: landedBubblePos.x, y: landedBubblePos.y, life: 0, duration: 25 });
    return bubblesPopped > 0;
}

function createExplosionEffect(x, y) { for (let i = 0; i < 60; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 6 + 2; popAnimations.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0, duration: POP_PARTICLE_DURATION + 30, color: Math.random() < 0.7 ? 'orange' : '#FFDD00', size: Math.random() * 8 + 5 });}}

function addNewRow() {
    for (let r = ROWS - 2; r >= 0; r--) {
        for (let c = 0; c < COLS; c++) {
            if (grid[r][c]) {
                grid[r + 1][c] = grid[r][c];
                grid[r + 1][c].row = r + 1;
                grid[r + 1][c].x = offsetX + c * HEX_WIDTH + ((r + 1) % 2) * BUBBLE_RADIUS;
                grid[r + 1][c].y = offsetY + (r + 1) * HEX_HEIGHT;
            } else {
                grid[r + 1][c] = null;
            }
        }
    }
    
    newRowsAdded++;
    const placeLifeBubbles = (newRowsAdded % 2 !== 0); 

    for (let c = 0; c < COLS; c++) {
        if (placeLifeBubbles && (c === 0 || c === COLS - 1)) {
            grid[0][c] = createBubble(0, c, '#ffffff', 'life');
        } else {
            grid[0][c] = createBubble(0, c);
        }
    }

    for (let c = 0; c < COLS; c++) {
        if (grid[ROWS - 1][c]) {
            endGame(false);
            return;
        }
    }
    rowDropTimer = 0;
}

function spawnBombBubble() { nextBubble = { type: 'bomb', color: '#444' }; updateUI(); bombTimer = 0; }
function prepareNextShot() {
    if(gameState!=='playing')return;
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);

    playerBubble={...nextBubble,x:canvas.width/2,y:canvas.height-BUBBLE_RADIUS};
    if(playerBubble.type === 'bomb') { sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.3 }); }
    if(playerBubble.type === 'rainbow') { rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.5 }); }

    nextBubble=generateNextBubble();
    updateUI();
}
function getNeighbors(r,c) { const p=r%2,d=[{dr:0,dc:1},{dr:0,dc:-1},{dr:-1,dc:p-1},{dr:-1,dc:p},{dr:1,dc:p-1},{dr:1,dc:p}],n=[];for(const i of d){const nr=r+i.dr,nc=c+i.dc;if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS&&!(nr%2===1&&nc===COLS-1))n.push({r:nr,c:nc})}return n}
function findMatches(startR, startC) { const startBubble = grid[startR][startC]; if (!startBubble) return []; let potentialMatches = new Map(); let toVisit = [{ r: startR, c: startC }]; let visited = new Set([`${startR},${startC}`]); while (toVisit.length > 0) { const current = toVisit.shift(); const bubble = grid[current.r][current.c]; getNeighbors(current.r, current.c).forEach(nCoord => { const neighbor = grid[nCoord.r]?.[nCoord.c]; if (neighbor && !visited.has(`${nCoord.r},${nCoord.c}`)) { if (neighbor.type === 'life') { visited.add(`${nCoord.r},${nCoord.c}`); toVisit.push(nCoord); } else if (startBubble.type === 'life' || neighbor.color === startBubble.color) { visited.add(`${nCoord.r},${nCoord.c}`); toVisit.push(nCoord); } } }); } visited.forEach(coordStr => { const [r, c] = coordStr.split(',').map(Number); const bubble = grid[r][c]; if(bubble){if (bubble.type !== 'life') { if (!potentialMatches.has(bubble.color)) { potentialMatches.set(bubble.color, []); } potentialMatches.get(bubble.color).push({ r, c }); }} }); const lifeBubbles = Array.from(visited).filter(coordStr => { const [r, c] = coordStr.split(',').map(Number); return grid[r][c]?.type === 'life'; }).map(coordStr => { const [r, c] = coordStr.split(',').map(Number); return {r,c}; }); for (const [color, bubbles] of potentialMatches.entries()) { if (bubbles.length + lifeBubbles.length >= 3) { return [...bubbles, ...lifeBubbles]; } } return [];}
async function findFloatingBubbles() { await new Promise(r => setTimeout(r, 50)); const o=new Set(),q=[];for(let c=0;c<COLS;c++)if(grid[0][c]){q.push({r:0,c:c});o.add(`0,${c}`)}let h=0;while(h<q.length){const u=q[h++];for(const n of getNeighbors(u.r,u.c))if(grid[n.r][n.c]&&!o.has(`${n.r},${n.c}`)){o.add(`${n.r},${n.c}`);q.push(n)}}const f=[];for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c]&&!o.has(`${r},${c}`))f.push({r,c});return f}
function isGridEmpty() { for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])return false; return true;}
function endGame(isWinner) {
    gameState='gameover';
    isFiring=false;
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    if(isWinner){
        endMessageEl.innerText = 'You Win!'; score += 1500; playSound('win', { gain: 0.5 }); createFirework();
    } else {
        endMessageEl.innerText = 'Sorry, you lost!'; playSound('lose', { gain: 0.5 }); createRain();
    }
    finalScoreEl.innerText = score;
    gameOverEl.style.display='flex';
}
function createFirework() { const x=Math.random()*canvas.width*0.8+canvas.width*0.1; const y=Math.random()*canvas.height*0.5+canvas.height*0.1; const color=`hsl(${Math.random()*360},100%,50%)`; for(let i=0;i<50;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*3+1;fireworks.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,color,size:Math.random()*2+1})}}
function createRain() { for(let i=0;i<100;i++){rain.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,len:Math.random()*20+10,speed:Math.random()*5+2})}}

function handleAimUpdate(clientX,clientY) {
    if(gameState!=='playing')return;
    const rect=canvas.getBoundingClientRect();
    aim.x=(clientX-rect.left)*(canvas.width/rect.width);
    aim.y=(clientY-rect.top)*(canvas.height/rect.height);
    const currentAngle = Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x);
    if (Math.abs(currentAngle - lastAimAngle) > 0.03) {
        aimClickCounter++;
        if (aimClickCounter % 3 === 0) {
            playSound('shick', { gain: 0.7 });
        }
        lastAimAngle = currentAngle;
    }
}
function handleFire() {
    if(gameState!=='playing'||isFiring||aim.y>playerBubble.y-20)return;
    playSound('shoot', { gain: 0.4 });
    const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x),speed=15;
    playerBubble.vx=Math.cos(angle)*speed;
    playerBubble.vy=Math.sin(angle)*speed;
    isFiring=true;
}

// --- Event Listeners ---
document.getElementById('continue-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});rulesOverlay.style.display='none';startOverlay.style.display='flex'});
document.getElementById('play-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});startOverlay.style.display='none';gameState='playing'});
document.getElementById('play-again-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});gameOverEl.style.display='none';init();startOverlay.style.display='flex'});
document.getElementById('restart-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});if(gameState==='playing'&&confirm('Are you sure you want to restart the game?')){init();startOverlay.style.display='flex'}else if(gameState!=='playing'){init();startOverlay.style.display='flex'}});
document.getElementById('level-up-continue-button').addEventListener('click', () => {
    initAudio(); playSound('click',{gain:0.4});
    levelUpOverlay.style.display = 'none';
    resetForNextLevel();
    gameState = 'playing';
});
audioToggleButton.addEventListener('click', () => {
    isMuted = !isMuted;
    audioToggleButton.innerText = isMuted ? "Sound: OFF" : "Sound: ON";
    if (isMuted) {
        sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
        rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    } else {
        initAudio();
        playSound('click', {gain: 0.4});
        if (playerBubble && playerBubble.type === 'bomb') sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.3 });
        if (playerBubble && playerBubble.type === 'rainbow') rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.5 });
    }
});

if(isMobile){canvas.addEventListener('touchmove',e=>{e.preventDefault();handleAimUpdate(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});canvas.addEventListener('touchend',e=>{e.preventDefault();handleFire()},{passive:false})}else{canvas.addEventListener('mousemove',e=>{handleAimUpdate(e.clientX,e.clientY)});canvas.addEventListener('click',handleFire)}

// --- Background Animation ---
function initBackground() { bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; backgroundBubbles = []; let bubbleCount = 30; for (let i = 0; i < bubbleCount; i++) { backgroundBubbles.push({ x: Math.random() * bgCanvas.width, y: Math.random() * bgCanvas.height, radius: Math.random() * 25 + 10, speed: Math.random() * 1 + 0.5, opacity: Math.random() * 0.3 + 0.1 });}}
function updateBackgroundBubbles() { for (let i = 0; i < backgroundBubbles.length; i++) { const b = backgroundBubbles[i]; b.y -= b.speed; if (b.y < -b.radius) { b.y = bgCanvas.height + b.radius; b.x = Math.random() * bgCanvas.width; b.speed = Math.random() * 1 + 0.5; b.radius = Math.random() * 25 + 10; }}}
function drawBackgroundBubbles() { bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height); for (let i = 0; i < backgroundBubbles.length; i++) { const b = backgroundBubbles[i]; let grad = bgCtx.createRadialGradient( b.x - b.radius * 0.3, b.y - b.radius * 0.3, 0, b.x, b.y, b.radius ); grad.addColorStop(0, `rgba(255, 255, 255, ${b.opacity + 0.2})`); grad.addColorStop(1, `rgba(174, 222, 252, ${b.opacity})`); bgCtx.fillStyle = grad; bgCtx.beginPath(); bgCtx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); bgCtx.fill();}}
window.addEventListener('resize', initBackground);

// --- Main Game Loop ---
function gameLoop() {
    updateBackgroundBubbles(); drawBackgroundBubbles();
    if (gameState === 'playing') update();
    if (gameState === 'gameover') { if (fireworks.length > 0) updateFireworks(); if (rain.length > 0) updateRain(); }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    if(gameState==='playing')drawBubble(ctx,playerBubble);
    if(gameState==='playing'&&!isFiring)drawAimingLine();
    drawPopAnimations(); drawFloatingPoints(); drawBombSparks(); drawShockwaves(); drawGameOverLine();
    if(gameState === 'gameover') { drawFireworks(); drawRain(); }
    requestAnimationFrame(gameLoop);
}

// --- Start Game ---
initBackground(); init(); gameLoop();
</script>
</body>
</html>
